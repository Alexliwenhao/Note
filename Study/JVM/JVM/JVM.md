



# JVM

![image-20201028132233167](image-20201028132233167.png)

![image-20201027200153555](image-20201027200153555.png)

![image-20201027204141800](image-20201027204141800.png)

## 一、类加载机制

![image-20201027203926810](image-20201027203926810.png)

常量池

![image-20201027205306858](image-20201027205306858.png)

方法区

![image-20201027214210202](image-20201027214210202.png)

类加载器

![image-20201027210047186](image-20201027210047186.png)

1. ​	装载

   1. 字节码文件 ----字节流 ----类加载器
   2. 将字节流代表的静态存储结构转化为方法区的运行时的数据结构
   3. java堆里面生成一个代表这个类的java.lang.Class对象。作为我们数据访问入口

2. 链接

   1. 验证：验证文件不能有问题
   2. 准备：为类的静态变量分配内存  给与默认值private static int a = 1;
   3. 解析：符号引用转变成直接引用

3. 初始化

   1. 给静态变量赋值     先初始化当前类的parent
   2. 分层次进行加载  计算对象的大小    40+20=60字节  64/8 =8 8字节初试位置为起始
      CPU效率    7U8     1U4  8U8

   

![image-20201027210637184](image-20201027210637184.png)

![image-20201027212848792](image-20201027212848792.png)



![image-20201027214441338](image-20201027214441338.png)

![image-20201028215112220](image-20201028215112220.png)

![image-20201028222046574](image-20201028222046574.png)

old 区默认是新生代的两倍，young区放不下的时候放到old区是因为**担保机制**

![image-20201028224633006](image-20201028224633006.png)

young GC/minor GC

内存空间的不连续性  空间碎片 

8:1:1是默认值，是可以修改的

old GC/ major GC  装不了就GC

full GC = minor GC + major GC +MetaSpace  GC

方法区  perm Space      JDK1.7  虚拟机内存

​				Meta Space   GC    1.8        使用的是Native 内存 

![image-20201028225720264](image-20201028225720264.png)

![image-20201028231900585](image-20201028231900585.png)

# 垃圾回收

## 1.判断对象是否死亡

1）引用计数法：

​	a.每当一个对象引用时，计数器加一，当计数器为0时对象死亡

​	b.缺点：无法解决循环引用问题，假设A引用B，B引用A，那么这两个对象不会	被回收

2）可达性分析  根搜索算法

​	a.通过一系列可作为GC ROOT的节点为起始点，从这节点开始往下搜索，所走过	的路径称为引用

​	b.当一个对象到GC ROOT没有引用链的时候说明这个对象不可用

​	c.可以作为GC ROOT 引用

1. 栈帧的局部变量表的元素
2. 本地方法栈JNI里面的元素
3. 方法区静态变量与常量

## 2.收垃圾

精准  高效   实现

1）标记-清处算法：直接将标记为死亡的对象清除

​	缺陷：效率低

​	缺点：清理出来的空间是不连续的，产生空间碎片

![image-20201028234314607](image-20201028234314607.png)

2）标记-整理算法 ：将可用对象统一移动向另外一端

  	存活时间长  不会去老是回收他 间隔长

3）复制算法：将堆分为Eden，SurvivorFrom，SurvivorTo空间

​	a.每次在Eden空间分配空间的时候

​	b.将Eden部分活跃对象复制到Survivor区

​	新生代  死得快 效率快  空间换时间

​	将可用容量划分成两块

![image-20201028234504132](image-20201028234504132.png)



4）分代收集算法

​	a.新生代：对象生存周期较短，只是少量的生存对象，适合使用复制算法

​	b.老年代：对象生存周期较长，只有少量需要回收对象，且无担保空间，所以使	用标记-整理算法

分治算法结合以上算法去使用

# 垃圾收集器

![image-20201029223540772](image-20201029223540772.png)

**串行垃圾回收**

serial	悠久	1.3之前	新生代	单线程	简单高效	很高的单线程收集效率

serial 	Old	老年代版本	单线程	标记整理

![image-20201029223929609](image-20201029223929609.png)

**并行垃圾回收**

ParNew	多线程版本	CPU多核

![image-20201029224719840](image-20201029224719840.png)

CPU双核什么意思？我们一个CPU上有两个运算核心

其他条件都一样的时候如何增加吞吐量？

业务代码时间/（业务代码时间+垃圾回收集时间） =   吞吐率

Parallel Scavenge 新生代的收集器	复制算法	并行的多线程垃圾收集器	系统吞吐量

Parallel Old	是老年代版本	多线程	标记-整理算法	系统吞吐量

应该改善停顿时间



**并发（垃圾收集线程和业务线程）类垃圾收集器**

CMS	垃圾收集器	分治思想	能不能全部并行（**四核以下不建议使用CMS**）

​	缺点：1.并发的阶段	4核支持	效率	切时间片

​				2.标记-清除	会产生内存碎片	影响停顿时间

​				3.并发失败

CMS：初始标记找到我们所有的GCROOT，然后再并发标记存活对象，因为找存货对象最耗时，同时产生新的垃圾在重新标记（STW）垃圾，并发清理 

![image-20201029225736174](image-20201029225736174.png)

**为啥初始标记是单线程而重新标计是多线程**？？

仅仅标记GC ROOT的时候比较快的，并发标记是因为业务线程要和标记线程一起跑，重新标记是因为线程已经开启了





**G1**	1.7的时候	比CMS的停顿时间更短	开发者自己设置	

​										解决空间碎片问题	

​								1.8推荐使用	1.9默认使用的垃圾收集器  

​								划分为大小相等的Region  约2048个    1M-32M

**内存空间重新定义**

![image-20201029232136856](image-20201029232136856.png)

Zero GC	JDK11才出现		停顿时间越低越好   8用不了	64位Linux   16G

## 垃圾收集器选择

![image-20201029234135559](image-20201029234135559.png)

## 参数

1. 标准参数	不随着JDK的版本变化而变化
2. -X非标准参数
3. -XX参数非标准参数
   1. 布尔类型
      1. -XX:[+/-]value     -XX:+UserG1GC
   2. name = value
      1. -XX:MaxHeapSize = 100M
      2. -XX:initialHeapSize=100M
4. 其他参数
   1. -Xms100M   等价于  -XX:initialHeapSize=100M
   2. -Xmx100M   等价于   -XX:MaxHeapSize = 100M
   3. -Xss128         等价于   -XX:ThreadStackSize=128

![image-20201029235539766](image-20201029235539766.png)

JDK提供一些常见的排查命令

JPS    	 PID

jinfo		

jstat		

jstack		

运行时数据区	堆的情况

对象的分布	分区分布

堆内存	对象使用率		OOM

jmap  	快照

**当使用G1的时候不能调整新生代和老年代的比例**

OOM    	大并发场景			限流

当要调整新生代和老年代的比例的时候一定是提前分析，提前调优

![image-20201030205842204](image-20201030205842204.png)

![image-20201030211543323](image-20201030211543323.png)

![image-20201030211755958](image-20201030211755958.png)

G1  -XX： +UseG1GC		低停顿	高吞吐	堆内存		不要手动设置新生代大小

G1会不断的调整我们的停顿时间



G1	手动设置	100ms -----200ms   full	GC      

不正常的Full  GC  老年代空间还很多  的时候

MetaSpace  GC和major  GC

![image-20201030212432289](image-20201030212432289.png)

