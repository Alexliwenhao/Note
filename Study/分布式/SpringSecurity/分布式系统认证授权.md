# 基本概念
### 什么是认证

**认证**：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。

### 什么是会话

用户认证通过后，为了避免用户的每次操作都进行认证，可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制，常见的有基于 session 方式、基于 token 方式等。
基于 session 的认证方式如下图：
![](media/1677636821324-320daaa5-f48f-40ec-b993-d1d543dbf841.jpeg.jpg)

它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在 session(当前会话)中，发给客户端的 sesssion_id 存放到 cookie 中，这样用 户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验，当用户退出系统或 session 过期销毁时,客户端的 session_id 也就无效了。
![](media/1677636822718-16d88a71-d387-4c8e-bb1b-57284d23c616.jpeg.jpg)
它的交互流程是，用户认证成功后，服务端生成一个 token 发给客户端，客户端可以放到 cookie 或 localStorage 等存储中，每次请求时带上 token，服务端收到 token 通过验证后即可确认用户身份。
基于 session 的认证方式由 Servlet 规范定制，服务端要存储 session 信息需要占用内存资源，客户端需要支持 cookie；基于 token 的方式则一般不需要服务端存储 token，并且不限制客户端的存储方式。如今移动互联网时代 更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于 token 的方式更适合。

### 什么是授权

还拿微信来举例子，微信登录成功后用户即可使用微信的功能，比如，发红包、发朋友圈、添加好友等，没有绑定银行卡的用户是无法发送红包的，绑定银行卡的用户才可以发红包，发红包功能、发朋友圈功能都是微信的资源即功能资源，用户拥有发红包功能的权限才可以正常使用发送红包功能，拥有发朋友圈功能的权限才可以使用发朋友圈功能，这个根据用户的权限来控制用户使用资源的
过程就是授权。认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的，控制不同的用户能够访问不同的资源。
授权：授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问。


授权可简单理解为 Who 对 What(which)进行 How 操作，包括如下：
Who：即主体（Subject），主体一般是指用户，也可以是程序，需要访问系统中的资源。
What：即资源 （Resource），如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按 钮、代码方法都属于系统功能资源，对于 web 系统每个功能资源通常对应一个 URL；系统商品信息、系统订单信息都属于实体资源（数据资源），实体资源由资源类型和资源实例组成，比如商品信息为资源类型，商品编号 为 001 的商品为资源实例。
How：权限/许可（Permission），规定了用户对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为 001 的用户的修改权限等，通过权限可知用户对哪些资源都有哪些操作许可。
![](media/1677636826009-26ff487e-7887-48a3-ab4c-82fab5b0760f.jpeg.jpg)主体、资源、权限关系如下图：

主体、权限、资源相关的数据模型如下：

- 主体（用户 id、账号、账号、密码、...）
- 资源（资源 id、资源名称、访问地址、...）
- 权限（权限 id、权限标识、权限名称、资源 id、...）
- 角色（角色 id、角色名称、...）
- 角色和权限关系（角色 id、权限 id、...）
- ![](media/1677636828503-fd609199-19a8-452c-962d-42beb10a8e27.jpeg.jpg)主体（用户）和角色关系（用户 id、角色 id、...）主体（用户）、资源、权限关系如下图：

通常企业开发中将资源和权限表合并为一张权限表，如下：资源（资源 id、资源名称、访问地址、...）
权限（权限 id、权限标识、权限名称、资源 id、...）合并为：
权限（权限 id、权限标识、权限名称、资源名称、资源访问地址、...）修改后的数据模型之前的关系如下图：
![](media/1677636829611-91ba5b09-7b2c-4469-bbc0-ba55c8d57a64.jpeg.jpg)

### RBAC

业界通常基于 RBAC 实现授权。
## 基于角色的访问控制
![](media/1677636830597-01ac03f8-67e6-4fdb-982e-f6418bb4e90f.jpeg.jpg)RBAC 基于角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：


基于上图中的控制逻辑，伪代码如下：

if (主体.hasRole("总经理角色 id")) {

// 查询工资

}

如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否为总经理或者部门经理”，如下：

if (主体.hasRole("总经理角色 id") || 主体.hasRole("部门经理角色 id")) {

// 查询工资

}

根据上边的例子可以发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。

## 基于资源的访问控制
RBAC 基于资源的访问控制（Resource-Based Access Control）是按资源
（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：
![](media/1677636832372-38d187cf-ff86-4171-ae70-43192144b06b.jpeg.jpg)
基于上图中的控制逻辑，伪代码如下：

if (主体.hasPermission("查询工资权限标识")) {

// 查询工资

}

优点：系统设计定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。

# Spring Security 介绍
### Spring Security 简介

Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码来完成认证过程。用户授权指的是验证
某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。
对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（ Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。

   1. 快速入门案例

## 创建 SpringBoot 工程
新建一个入门案例工程 spring-security-demo，引入如下依赖：
<**parent**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-parent</**artifactId**>
<**version**>2.1.6.RELEASE</**version**>
</**parent**>

<**dependencies**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-web</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-security</**artifactId**>
</**dependency**>
</**dependencies**>
添加 application.yml 配置：
**server**: **port**: 8080
**spring**: **application**:
**name**: security-demo
创建启动类：

@SpringBootApplication
**public class **SecurityApplication {
**public static void **main(String[] args) { SpringApplication._run_(SecurityApplication.**class**, args);
}
}
创建测试演示用的 LoginController：
@RestController
**public class **LoginController {

@RequestMapping(**"/login-success"**)
**public **String loginSuccess(){
**return "登录成功"**;
}

@RequestMapping(**"/r/r1"**)
**public **String resourceOne(){
**return "访问资源 1"**;
}

@RequestMapping(**"/r/r2"**)
**public **String resourceTwo(){
**return "访问资源 2"**;
}
}

## 添加 Security 配置

Spring Security 安全配置主要包含以下几部分：
1、定义用户信息服务(查询用户信息)
2、密码编码器(密码加密处理)
3、HTTP 请求安全拦截机制
在 config 目录下新建 WebSecurityConfig 配置类，它需要继承 WebSecurityConfigurerAdapter 类，在里面完成上面的三个配置，参考代码如下：
@Configuration
**public class **WebSecurityConfig **extends**
WebSecurityConfigurerAdapter {
_/*_
_*1、定义用户信息服务(查询用户信息)_
_*2、密码编码器(密码加密处理)_
_*3、HTTP 请求安全拦截机制_
_* */_

@Override @Bean
**public **UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = **new**
InMemoryUserDetailsManager();

manager.createUser(User._withUsername_(**"zhangsan"**).password(**"123"**). authorities(**"p1"**).build());

manager.createUser(User._withUsername_(**"lisi"**).password(**"123"**).auth orities(**"p2"**).build());
**return **manager;
}

@Bean
**public **PasswordEncoder passwordEncoder() {
_//使用明文匹配的方式来校验密码_
**return **NoOpPasswordEncoder._getInstance_();
}

@Override
**protected void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
_//访问'r/r1'需要'p1'权限_
.antMatchers(**"/r/r1"**).hasAuthority(**"p1"**)
_//访问'r/r2'需要'p2'权限_
.antMatchers(**"/r/r2"**).hasAuthority(**"p2"**)
_//所有访问'/r/**'的请求都需要经过认证_
.antMatchers(**"/r/**"**).authenticated()
_//其他请求都放行_
.anyRequest().permitAll()
.and()
_//允许使用表单登录_
.formLogin()
_//登录成功后跳转到'/login-success',使用'POST'访问请求_
.successForwardUrl(**"/login-success"**);
}
}
配置UserDetailsService 是为了让 Security 框架知道如何获取用户信息进
行认证，此处为了演示方便简单使用内存模拟的方式，将用户信息放到内存里面，
用户登录时直接从内存中取出用户信息进行验证。
PasswordEncoder 的配置是让 Security 框架在进行密码比对时，先对输入密码进行何种方式处理(加密)，此处采用的方式是不作处理，直接明文比对。
configure 方法里面的配置内容是最主要的安全拦截配置，Security 框架通过该配置获取具体的 web 请求拦截规则。
## 测试验证
浏览器访问 http://localhost:8080/login 进入 Spring Security 提供的默认登录页面。
![](media/1677636834840-68c37a48-8d01-41c9-9ee4-ab50c5857d17.png)
输入用户和密码登录测试。使用“zhangsan”登录，分别访问“/r/r1”和 “/r/r2”验证授权功能。
浏览器输入 http://localhost:8080/logout 可使用 Security 提供的默认退出登录接口。

   1. 工作原理

## Security 整体结构
Spring Security 所解决的问题就是安全访问控制，本质上其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源，其通过 Filter 或 AOP 等技术来实现请求拦截，底层通过 FilterChainProxy 代理去调用各种 Filter(Filter 链)，Filter 通过调用 AuthenticationManager 完成认证 ，通过调用 AccessDecisionManager 完成授权。
Spring Security 过滤器链结构如下图所示：

![](media/1677636835373-3ba06002-fcec-4b44-8753-6f5dbe139efc.jpeg.jpg)
###### SecurityContextPersistenceFilter
Filter 的入口和出口，它是用来将 SecurityContext(认证的上下文，里面有登录成功后的认证授权信息) 对象持久到 Session 的 Filter ， 同时会把 SecurityContext 设置给 SecurityContextHolder 方便我们获取用户认证授权信息。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存 到 配 置 好 的 DecurityContextRepository 中 ， 同 时 清 除 SecurityContextHolder 中的 SecurityContext。
SecurityContextPersistenceFilter 它的作用就是请求来的时候将包含了认证授权信息的 SecurityContext 对象从 SecurityContextRepository 中取出交给 SecurityContextHolder 工具类，方便我们通过 SecurityContextHolder 获取 SecurityContext 从而获取到 认证授 权信息， 请 求走的 时候又把 SecurityContextHolder 清空。
###### UsernamePasswordAuthenticationFilter
默认拦截“/login”登录请求，处理表单提交的登录认证，将请求中的认证信息包括 username,password 等封装成 UsernamePassword- AuthenticationToken，然后调用 AuthenticationManager 的认证方法进行认证。

- BasicAuthenticationFilter

基本认证，支持 httpBasic 认证方式的 Filter。

- RememberAuthenticationFilter

记住我功能实现的 Filter。

- AnonymousAuthenticationFilter

匿名 Filter，用来处理匿名访问的资源，如果用户未登录， SecurityContext 中没有 Authentication，就会创建匿名的 Token(AnonymousAuthenticationToken),然后通过 SecurityContextHodler设置到 SecurityContext 中。
###### ExceptionTranslationFilter
用来捕获 FilterChain 所有的异常， 并进行处理， 但是只会处理 AuthenticationException 和 AccessDeniedException 异常，其他的异常会继续抛出。
###### FilterSecurityInterceptor
用来做授权的 Filter，通过父类 (AbstractSecurityInterceptor.beforeInvocation)调用 AccessDecisionManager.decide 方法对用户进行授权。
## Security 相关概念
###### Authentication
认证对象，用来封装用户的认证信息(账户状态，用户名，密码，权限等)所有提交给 AuthenticationManager 的认证请求都会被封装成一个 Token 的实现，比如最容易理解的 UsernamePasswordAuthenticationToken，其中包含了用户名和密码。
Authentication 常用的实现类：

- UsernamePasswordAuthenticationToken：用户名密码登录的 Token
- AnonymousAuthenticationToken：针对匿名用户的 Token
- ![](media/1677636836865-1acb0785-c860-4c58-8048-6e6ae48fa004.png)RememberMeAuthenticationToken：记住我功能的的 Token




Authentication  直 接 继 承 自 Principal  类 ， 而 Principal  是 位 于 
java.security 包中的。它是表示着一个抽象主体身份，任何主体都有一个名称，包含一个 getName()方法。
getAuthorities()，权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。
getCredentials()，凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。
getDetails() ， 细 节 信 息 ， web	应 用 中 的 实 现 接 口 通 常 为
WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。
**getPrincipal()**，身份信息，大部分情况下返回的是 UserDetails 接口的实现类，UserDetails 代表用户的详细信息，从 Authentication 中取出来的 UserDetails 就是当前登录用户信息，它也是框架中的常用接口之一。
###### AuthenticationManager
用户认证的管理类，所有的认证请求（比如 login）都会通过提交一个封装了登录信息的 Token 对象给 AuthenticationManager 的 authenticate()方法来实现认证。AuthenticationManager 会调用 AuthenticationProvider.authenticate 进行认证。认证成功后，返回一个包含了认证信息的 Authentication 对象。AuthenticationManager 默认的实现类是 ProviderManager。
###### AuthenticationProvider
认证的具体实现类，一个 provider 是一种认证方式的实现，比如提交的用户名密码通过和 DB 中查出的 user 记录做比对实现认证，那就有一个 DaoProvider；如果是通过 CAS 请求单点登录系统实现，那就有一个 CASProvider。按照 Spring 一贯的作风，主流的认证方式它都已经提供了默认实现，比如 DAO、LDAP、CAS、OAuth2 等。 前面讲了 AuthenticationManager 只是一个代理接口，真正的认证就是由 AuthenticationProvider 来做的。一个 AuthenticationManager 可以包含多个 Provider，每个 provider 通过实现一个 support 方法来表示自己支持那种 Token 的认证。
AuthenticationProvider 默认实现是 DaoAuthenticationProvider，它的作用是根据传入的 Token 中的 username 调用 UserDetailService 加载数据库中的认证授权信息(UserDetails)，然后使用 PasswordEncoder 对比用户登录密码是否正确。
**在入门案例中，当 web 表单提交用户名密码时，Spring Security 由**
**DaoAuthenticationProvider 处理的。**

- **UserDetailService**

用户的认证通过 Provider（比如：DaoAuthenticationProvider）来完成，而 Provider 会通过 UserDetailService 拿到数据库（或内存）中的认证信息然后和客户端提交的认证信息做校验。虽然叫 Service,但是可以把它认为是我们系统里经常有的 UserDao。
别把 DaoAuthenticationProvider 和 UserDetailsService 的职责搞混淆， UserDetailsService 只负责从特定的地方（通常是数据库）加载用户信息。而 DaoAuthenticationProvider 的职责更大，它完成完整的认证流程，同时会把 UserDetails 填充至 Authentication。
###### ![](media/1677636838442-6baed823-ac2a-4f1e-a9a5-3e9834269aac.png)UserDetails
它和Authentication 接口很类似，比如它们都拥有 username，authorities。 Authentication 的 getCredentials()与 UserDetails 中的 getPassword()需要 被区分对待，前者是用户提交的密码凭证，后者是用户实际存储的密码，认证其实就是对这两者的比对。Authentication 中的 getAuthorities() 实际是由 UserDetails 的 getAuthorities()传递而形成的。还记得 Authentication 接口中 的 getDetails() 方法吗？ 其中的 UserDetails 用户详细信息便是经过了 AuthenticationProvider 认证之后被填充的。
通过实现 UserDetailsService 和 UserDetails，我们可以完成对用户信息获取 方 式 以 及 用 户 信 息 字 段 的 扩 展 。 Spring Security 提 供 的 InMemoryUserDetailsManager(内存认证)，JdbcUserDetailsManager( jdbc认证)就是 UserDetailsService 的实现类，主要区别无非就是从内存还是从数据库加载用户。

- PasswordEncoder

![](media/1677636838859-61e2330d-7716-48cb-a76c-2d44679e966c.png)主要负责完成对密码进行比对，具体的比对细节取决于实现类。

Spring Security 提供很多内置的 PasswordEncoder，能够开箱即用，实际项 目 中 推 荐 使 用 BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder 等。
###### SecurityContext
当用户通过认证之后，就会为这个用户生成一个唯一的 SecurityContext，里面包含用户的认证信息 Authentication。通过 SecurityContext 我们可以获取到用户的标识 Principle 和授权信息 GrantedAuthrity。在系统的任何地方只要通过 SecurityHolder.getSecruityContext()就可以获取到 SecurityContext。
## Security 认证流程
![](media/1677636839963-1c555733-05f4-45c7-9dcc-bfaf5a1363d4.jpeg.jpg)
1、请求过来会被过滤器链中的 UsernamePasswordAuthenticationFilter 拦截到，请求中的用户名和密码被封装成 UsernamePasswordAuthenticationToken(Authentication 的实现类)。
2、过滤器将 UsernamePasswordAuthenticationToken 提交给认证管理器

(AuthenticationManager)进行认证。
3、AuthenticationManager 委托 AuthenticationProvider (DaoAuthenticationProvider)进行认证，AuthenticationProvider 通过调用 UserDetailsService 获取到数据库中存储的用户信息(UserDetails)，然后调用 passwordEncoder 密码编码器对 UsernamePasswordAuthenticationToken中的密码和 UserDetails 中的密码进行比较。
4、AuthenticationProvider 认证成功后封装 Authentication 并设置好用户的信息(用户名，密码，权限等)返回。
5、Authentication 被返回到 UsernamePasswordAuthenticationFilter,通过调用 SecurityContextHolder 工具把Authentication 封装到 SecurityContext 中存 储 起 来 。 然 后 UsernamePasswordAuthenticationFilter 调 用 AuthenticationSuccessHandler.onAuthenticationSuccess 做认证成功后续处理操作。
6、最后 SecurityContextPersistenceFilter 通过 SecurityContextHolder.getContext()获取到 SecurityContext 对象然后调用 SecurityContextRepository 将 SecurityContext 存储起来。然后调用 SecurityContextHolder.clearContext 方法清理 SecurityContext。注意： SecurityContext 是一个和当前线程绑定的工具，在代码的任何地方都可以通过 SecurityContextHolder.getContext()获取到登陆信息。

## Security 授权流程
![](media/1677636842268-705f03d2-d832-4637-9eb9-6bbeb9c5cf1b.jpeg.jpg)
1、当客户端向某个资源发起请求，请求到达 FilterSecurityInterceptor，然后会调用其父类 AbstractSecurityInterceptor 的 beforeInvocation 方法做授权之前的准备工作。
2、在 beforeInvocation 法中通过 SecurityMetadataSource.getAttributes(object);获得资源所需要的访问权  限 ，通过 SecurityContextHolder.getContext().getAuthentication()获取当前认证用户的认证信息，即包含了认证信息和权限信息的 Authentication 对象。
3、然后 FilterSecurityInterceptor 通过调用 AccessDecisionManager.decide(authenticated, object, attributes);进行授权(authenticated 中有用户的权限列表，attributes 是资源需要的权限)，该方法使用投票器投票来决定用户是否有资源访问权限。
Spring Security 内置了三个基于投票的AccessDecisionManager 实现类，它们分别是 AffirmativeBased、ConsensusBased 和 UnanimousBased。通过接口 AccessDecisionVoter 完成投票（可简单理解为进行资源所需权限和用户拥有权限的对比）。


![](media/1677636842659-b87a9185-a0e2-4005-8a90-d93a128529e6.png)

vote()方法的返回结果会是 AccessDecisionVoter 中定义的三个常量之一。
ACCESS_GRANTED 表示同意，ACCESS_DENIED 表示拒绝，ACCESS_ABSTAIN
表示弃权。如果一个 AccessDecisionVoter 不能判定当前 Authentication 是否拥有访问对应受保护对象的权限， 则其 vote() 方法的返回值应当为弃权 ACCESS_ABSTAIN。

- AffirmativeBased

只需有一个投票赞成即可通过。默认使用这种方式。

- ConsensusBased

需要大多数投票赞成即可通过，平票可以配置。

- UnanimousBased

需要所有的投票赞成才能通过。

##### Web 授权

在 Security 配置类中，可以通过 HttpSecurity.authorizeRequests()给资源指定访问的权限，其 API 如下：

- anyRequest():任何请求
- antMatchers("/path")：匹配某个资源路径
- authenticationed() : 保护 URL 需要登录访问
- permitAll():指定 url 无需保护(放行)一般用户静态资源
- hasRole(String role)：某个资源需要用户拥有什么样的 role 才能访问
- hasAuthority(String authority):某个资源需要用户拥有什么样的权限才能访问
- hasAnyRole(String …roles):某个资源拥有指定角色中的一个就能访问
- hasAnyAuthority(String … authorities):某个资源拥有指定权限中的一个就能访问
- access(String attribute):该方法使用 SPEL 表达式,可以创建复杂的限制
- hasIpAddress(String ip):拥有什么样的 ip 或子网可以访问该资源
###### 注意事项：
![](media/1677636843755-289d2411-4f05-4b44-bcb0-dfbcc6d18537.png)通常把细节的规则设置在前面，范围比较大的规则设置放在后面，举个反例：


那么第二个权限规则将不起作用，因为第一个权限规则覆盖了第二个权限规则,权限的设置是按照从上到下的优先级,满足了最开始的权限设置，那么后面的设置就不起作用了。

##### 方法授权

Spring Security 提供了一些授权的注解，可以在 service,controller 等的方法上使用注解进行授权，即在方法上指定需要什么样的权限才能访问。
###### @Secured
这个注解需要在配置类上开启授权注解支持。
![](media/1677636844830-e804c37e-061f-45a7-a64b-80b3c2b9028c.jpeg.jpg)1、开启 Secured 授权支持
![](media/1677636845313-38e3d0fd-fbd7-4ea8-ba44-b950e6db929e.jpeg.jpg)
2、使用@Secured 进行方法授权



这里使用了 @Secured("ROLE_employee:list") 意思是 "/employee/list" 这个资源需要"ROLE_employee:list"权限才能访问，如果认证的用户有该权限 (UserDetailService 中加载)包含了"ROLE_employee:list"即可访问该资源，否则不能访问。
注意：对于方法授权，没有贴注解的方法默认是匿名访问。@Secured 注解授权是需要加上前缀"ROLE_"。
###### @PreAuthorize
PreAuthorize 适合进入方法前的权限验证，拥有和 Secured 同样的功能，甚至更强大，该注解需要在配置类开启： @EanbleGlobalMethodSecurity(prePostEnabled=true) 方法授权支持。

![](media/1677636846063-cc08a25c-27bb-4179-a0ec-e2822b8085ac.jpeg.jpg)1、开启@PreAuthorize 授权支持
2、使用@PreAuthorize 进行方法授权
![](media/1677636846480-ff66e4b9-6724-4bcf-a842-cf51e0918d5a.jpeg.jpg)
指明了方法必须要有 employee:add 或者 employee:update 的权限才能访问，该注解不需要有固定的前缀。注意格式 @PreAuthorize("hasAuthority('employee:add')")，hasAuthority 不能省略，括号中是单引号。
###### @PostAuthorize
该注解使用并不多，适合在方法执行后再进行权限验证，使用该注解需要在配置类开启：@EanbleGlobalMethodSecurity(prePostEnabled=true) 方法授权支持，用法同 @PreAuthorize 一样。

   1. 完善入门案例

## 创建数据库表

-- 用户表
**CREATE TABLE **`t_user` **(**
`id` **BIGINT (**20**) NOT NULL COMMENT **'用户 id'**,**
`username` **VARCHAR (**64**) NOT NULL,**
`password` **VARCHAR (**64**) NOT NULL,**
`fullname` **VARCHAR (**255**) NOT NULL COMMENT **'用户姓名'**,**
`mobile` **VARCHAR (**11**) DEFAULT NULL COMMENT **'手机号'**, PRIMARY KEY (**`id`**) USING **BTREE
**) **ENGINE **= **INNODB **DEFAULT **CHARSET **= **utf8 ROW_FORMAT **= DYNAMIC;**
-- 角色表
**CREATE TABLE **`t_role` **(**
`id` **VARCHAR (**32**) NOT NULL,**
`role_name` **VARCHAR (**255**) DEFAULT NULL,**
`description` **VARCHAR (**255**) DEFAULT NULL,**
`create_time` **datetime DEFAULT NULL,**
`update_time` **datetime DEFAULT NULL,**
`status` **CHAR (**1**) NOT NULL, PRIMARY KEY (**`id`**),**
**UNIQUE KEY **`unique_role_name` **(**`role_name`**)**
**) **ENGINE **= **INNODB **DEFAULT **CHARSET **= **utf8**;**
**insert into**
`t_role`**(**`id`**,**`role_name`**,**`description`**,**`create_time`**,**`update_time`**,**` status`**) values**
**(**'1'**,**'管理员'**,NULL,NULL,NULL,**''**);**
-- 用户角色关系表
**CREATE TABLE **`t_user_role` **(**
`user_id` **VARCHAR (**32**) NOT NULL,**
`role_id` **VARCHAR (**32**) NOT NULL,**
`create_time` **datetime DEFAULT NULL,**
`creator` **VARCHAR (**255**) DEFAULT NULL,**
**PRIMARY KEY (**`user_id`**, **`role_id`**)**
**) **ENGINE **= **INNODB **DEFAULT **CHARSET **= **utf8**;**
**insert into**
`t_user_role`**(**`user_id`**,**`role_id`**,**`create_time`**,**`creator`**) values (**'1'**,**'1'**,NULL,NULL);**
-- 权限表
**CREATE TABLE **`t_permission` **(**
`id` **VARCHAR (**32**) NOT NULL,**
`code` **VARCHAR (**32**) NOT NULL COMMENT **'权限标识符'**,**
`description` **VARCHAR (**64**) DEFAULT NULL COMMENT **'描述'**,**
`url` **VARCHAR (**128**) DEFAULT NULL COMMENT **'请求地址'**, PRIMARY KEY (**`id`**)**
**) **ENGINE **= **INNODB **DEFAULT **CHARSET **= **utf8**;**
**insert into **`t_permission`**(**`id`**,**`code`**,**`description`**,**`url`**) values (**'1'**,**'p1'**,**'测试资源
1'**,**'/r/r1'**),(**'2'**,**'p3'**,**'测试资源 2'**,**'/r/r2'**);**
-- 角色权限关系表
**CREATE TABLE **`t_role_permission` **(**
`role_id` **VARCHAR (**32**) NOT NULL,**
`permission_id` **VARCHAR (**32**) NOT NULL, PRIMARY KEY (**`role_id`**, **`permission_id`**)**
**) **ENGINE **= **INNODB **DEFAULT **CHARSET **= **utf8**;**
**insert into **`t_role_permission`**(**`role_id`**,**`permission_id`**) values (**'1'**,**'1'**),(**'1'**,**'2'**);**
## 添加依赖

<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-test</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-jdbc</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>mysql</**groupId**>
<**artifactId**>mysql-connector-java</**artifactId**>
<**version**>8.0.27</**version**>
</**dependency**>
<**dependency**>
<**groupId**>org.projectlombok</**groupId**>
<**artifactId**>lombok</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>com.alibaba</**groupId**>
<**artifactId**>fastjson</**artifactId**>
<**version**>1.2.78</**version**>
</**dependency**>
在入门案例 pom 文件中添加以上依赖。
## 配置数据库连接
在入门案例 application.yml 文件中添加数据连接相关配置。
**server**: **port**: 8080
**spring**: **application**:
**name**: security-demo
**datasource**:
**url**: jdbc:mysql://192.168.10.207:3306/user-db?useUnicode=true
**username**: root
**password**: 123456
**driver-class-name**: com.mysql.cj.jdbc.Driver
## 编写用户信息查询代码
创建 model 包，新增UserDto 和 PermissionDto。
@Data
**public class **UserDto { **private **String **id**; **private **String **username**; **private **String **password**; **private **String **fullname**; **private **String **mobile**;
}


@Data
**public class **PermissionDto {

**private **String **id**; **private **String **code**;
**private **String **description**; **private **String **url**;
}
创建 dao 包，新增 UserDao 编写数据库查询逻辑。
@Repository
**public class **UserDao { @Resource
**private **JdbcTemplate **jdbcTemplate**;

_/**_
_* 根据账号查询用户信息_
_*/_
**public **UserDto getUserByUsername(String username) {
String sql = **"select id,username,password,fullname,mobile from t_user where username = ?"**;
_//连接数据库查询用户_
List<UserDto> list = **jdbcTemplate**.query(sql, **new**
Object[]{username},
**new **BeanPropertyRowMapper<>(UserDto.**class**));
**if **(list != **null **&& list.size() == 1) {
**return **list.get(0);
}
**return null**;
}
_/**_
_* 根据用户 id 查询用户权限_
_*/_
**public **List<String> findPermissionsByUserId(String userId) { String sql = **"SELECT **_* _**FROM t_permission WHERE id IN(\n" **+
**"\n" **+
**"SELECT permission_id FROM t_role_permission WHERE role_id IN(\n" **+
**" SELECT role_id FROM t_user_role WHERE user_id = ? \n"**
+
**")\n" **+
**")\n"**;

List<PermissionDto> list = **jdbcTemplate**.query(sql, **new**
Object[]{userId},
**new **BeanPropertyRowMapper<>(PermissionDto.**class**)); List<String> permissions = **new **ArrayList<>(); list.forEach(c -> permissions.add(c.getCode())); **return **permissions;
}
}

## 自定义 UserDetailsService

![](media/1677636850597-4e3f1e35-4e75-4288-8780-e8e20fd9ca61.png)修改入门案例中的配置类 WebSecurityConfig，删除掉之前的用户信息获取配置，即移除以下代码：
创建 service 包，新增 CustomUserDetailsService 类实现 UserDetailsService 接口，提供自定义用户信息获取逻辑。 @Service
**public class **CustomUserDetailsService **implements**
UserDetailsService { @Resource
**private **UserDao **userDao**;

@Override
**public **UserDetails loadUserByUsername(String username) **throws**
UsernameNotFoundException {
_//将来连接数据库根据账号查询用户信息_
UserDto userDto = **userDao**.getUserByUsername(username); **if**(userDto == **null**){
_//如果用户查不到，返回 null，由 provider 来抛出异常_
**return null**;
}
_//根据用户的 id 查询用户的权限_
List<String> permissions =
**userDao**.findPermissionsByUserId(userDto.getId());
_//将 permissions 转成数组_
String[] permissionArray = **new **String[permissions.size()]; permissions.toArray(permissionArray);
_//将 userDto 转成 json_
String principal = JSON._toJSONString_(userDto); UserDetails userDetails =
User._withUsername_(principal).password(userDto.getPassword())
.authorities(permissionArray).build();
**return **userDetails;
}
}

## 修改 PasswordEncoder

修改 WebSecurityConfig 中 PasswordEncoder 的实现，使用
BcryptPasswordEncoder 来处理加密密码的比对。
@Bean
**public **PasswordEncoder passwordEncoder() {
_//使用 BCryptPasswordEncoder_
**return new **BCryptPasswordEncoder();
}
![](media/1677636851678-f2164ec5-5edb-43a6-bbbb-b4f3c0f90c79.jpeg.jpg)数据中的密码采用加密存储：
使用 Bcrypt 获取加密密码及密码校验，参考如下代码：
@Test
**public void **testBcryt(){
_//对密码进行加密_
String hashpw = BCrypt._hashpw_(**"secret"**, BCrypt._gensalt_()); System.**_out_**.println(hashpw);
_//校验密码_
**boolean **checkpw = BCrypt._checkpw_(**"123"**,

**"$2a$10$aFsOFzujtPCnUCUKcozsHux0rQ/3faAHGFSVb9Y.B1ntpmEhjRtru"**); **boolean **checkpw2 = BCrypt._checkpw_(**"123"**,

**"$2a$10$HuClcUqr/FSLmzSsp9SHqe7D51Keu1sAL7tUAAcb..FyILiLdFKYy"**); System.**_out_**.println(checkpw);
System.**_out_**.println(checkpw2);
}

## 测试验证
执行入门案例中的认证授权测试过程。

##### 方法授权测试

修改 WebSecurityConfig 中安全拦截配置，去掉 Web 授权相关的配置，并开启方法授权，参考如下代码：
@Configuration @EnableGlobalMethodSecurity(prePostEnabled = **true**) **public class **WebSecurityConfig **extends **WebSecurityConfigurerAdapter {

_/**_
_* 密码编码器(密码加密处理)_
_*/_
@Bean
**public **PasswordEncoder passwordEncoder() {
_//使用 BCryptPasswordEncoder_
**return new **BCryptPasswordEncoder();
}

_/**_
_* HTTP 请求安全拦截机制_
_*/_
@Override
**protected void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
.antMatchers(**"/r/**"**).authenticated()
_//其他请求都放行_
.anyRequest().permitAll()
.and()
_//允许使用表单登录_
.formLogin()
_//登录成功后跳转到'/login-success',使用'POST'访问请求_
.successForwardUrl(**"/login-success"**);
}
}
在 LoginController 中添加方法授权拦截注解：

@RestController
**public class **LoginController {

@RequestMapping(**"/login-success"**)
**public **String loginSuccess(){
**return "登录成功"**;
}

@RequestMapping(**"/r/r1"**) @PreAuthorize(**"hasAnyAuthority('p1')"**) **public **String resourceOne(){
**return "访问资源 1"**;
}

@PreAuthorize(**"hasAnyAuthority('p2')"**) @RequestMapping(**"/r/r2"**)
**public **String resourceTwo(){
**return "访问资源 2"**;
}
}
再次重复前面的测试过程。
## 获取用户身份信息
用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。spring security 提供会话管理，认证通过后将身份信息放入 SecurityContextHolder 上下文，SecurityContext 与当前线程进行绑定，方便获取用户身份。
修改 LoginController 代码，在/r/r1 和/r/r2 接口返回结果中增加返回用户信息，通过 SecurityContextHolder.getContext().getAuthentication()获取用户信息，参考代码如下：
@RestController
**public class **LoginController {

@RequestMapping(**"/login-success"**)
**public **String loginSuccess() {
**return "登录成功"**;
}

@RequestMapping(**"/r/r1"**) @PreAuthorize(**"hasAnyAuthority('p1')"**) **public **String resourceOne() {**return **getUserName() + **"访问资源 1"**;
}

@PreAuthorize(**"hasAnyAuthority('p2')"**) @RequestMapping(**"/r/r2"**)
**public **String resourceTwo() {
**return **getUserName() + **"访问资源 2"**;
}

**private **String getUserName() { Authentication authentication =
SecurityContextHolder._getContext_().getAuthentication();
**if **(!authentication.isAuthenticated()) {
**return null**;
}
Object principal = authentication.getPrincipal(); String username;
**if **(principal **instanceof **UserDetails) { String usernameStr = ((UserDetails)
principal).getUsername();
UserDto userDto = JSON._parseObject_(usernameStr, UserDto.**class**);
username = userDto.getUsername();
} **else **{
username = principal.toString();
}
**return **username;
}
}

## 会话控制

我们可以通过以下选项准确控制会话何时创建以及Spring Security 如何与之交
互：

| **机制** | **描述** |
| --- | --- |
| always | 如果没有 session 存在就创建一个 |
| ifRequired | 如果需要就创建一个 Session（默认）登录时 |
| never | SpringSecurity 将不会创建 Session，但是如果应用中其他地方创建了 Session，那么 Spring Security 将会使用它。 |
| stateless | SpringSecurity 将绝对不会创建 Session，也不使用 Session |

通过以下配置方式对该选项进行配置：
@Override
**protected void **configure(HttpSecurity http) **throws **Exception { http.sessionManagement()
.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
}
默认情况下，Spring Security 会为每个登录成功的用户会新建一个 Session，
就是 ifRequired 。
若选用 never，则指示Spring Security 对登录成功的用户不创建 Session了，但若你的应用程序在某地方新建了 session，那么 Spring Security 会用它的。
若使用 stateless，则说明 Spring Security 对登录成功的用户不会创建 Session 了，你的应用程序也不会允许新建session。并且它会暗示不使用cookie，所以每个请求都需要重新进行身份验证。这种无状态架构适用于 REST API 及其 无状态认证机制。
###### 会话超时
可以再 sevlet 容器中设置 Session 的超时时间，如下设置 Session 有效期为 3600s:
在 appliaction.yml 中添加：
server.servlet.session.timeout=3600s
session 超时之后，可以通过 Spring Security 设置跳转的路径。
http.sessionManagement()
.expiredUrl("/login‐view?error=EXPIRED_SESSION")
.invalidSessionUrl("/login‐view?error=INVALID_SESSION");
expired 指 session 过期，invalidSession 指传入的 sessionid 无效。

###### 安全会话 cookie
可以使用 httpOnly 和 secure 标签来保护我们的会话 cookie： **httpOnly**：如果为 true，那么浏览器脚本将无法访问 cookie **secure**：如果为 true，则 cookie 将仅通过HTTPS 连接发送
可在 application.yml 中添加如下配置进行实现：
server.servlet.session.cookie.http‐only=true server.servlet.session.cookie.secure=true

# 分布式系统认证方案
随着软件环境和需求的变化，软件的架构由单体结构演变为分布式架构，具有分布式架构的系统叫做分布式系统，分布式系统的运行通畅依赖网络，它将单体结构系统拆分为若干服务，服务之前通过网络交互来完成用户的业务处理，当前流行的微服务架构就是分布式架构，如下图：
![](media/1677636854780-99cc825a-c97a-4628-92a8-a7c03eee067b.jpeg.jpg)

### 分布式认证需求

分布式系统的每个服务都会有认证、权限的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务处理系统认证授权的请求；考虑分布式系统开放性的特点，不仅对系统内部提供认证，对第三方系统也要提供认证，分布式认证的需求总结如下：
**统一认证授权**：
提供独立的认证服务，统一处理认证授权。
无论是不同类型的用户，还是不同种类的客户端（web、H5、APP），均采用一致的认证、权限、会话机制，实现统一认证授权。
要实现统一，则认证方式必须可扩展，支持各种认证需求，比如：用户名密码认证、短信认证、二维码、人脸识别等认证方式，并可以非常灵活的切换。
**应用接入认证**：
应提供扩展和开放能力，提供安全的系统对接机制，并可开放部分 API 给接入第三方使用，一方应用（内部系统服务）和第三方（第三方应用）均采用统一机制接入。

### 选型分析

- 基于 session 认证方式

在分布式环境下，基于 session 的认证会出现一个问题，每个应用服务都需要在 session 中存储用户身份信息，通过负载均衡本地的请求分配到另一个应用服务器需要将 session 信息带过去，否则会重新认证。
![](media/1677636855709-adf00f4e-5801-48ae-b46c-9b6d0470a002.jpeg.jpg)
通常的做法有以下几种：
Session 复制：多台应用服务器之间同步 session，使 session 保持一致，对外透明。

Session 黏贴：当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上。
Session 集中存储：将 Session 存入分布式缓存中，所有服务器应用实例统一从分布式缓存中存取 Session。

- 基于 token 的认证方式

基于 token 的认证方式，服务器不用存储认证数据，易维护扩展性强，客户端可以把 token 存在任意地方，并且可以实现 web 和 App 统一认证机制。其缺点也很明显，token 由于自身包含信息，因此一般数据量较大，而且每次请求都需要传递，因此比较占带宽。另外，token 的签名验签操作也会给 CPU 带来额外的处理负担。
![](media/1677636856845-cef259ec-eec7-4b5c-a853-cfe00d73a31b.jpeg.jpg)

### 技术方案

根据选型的分析，本课程中采用基于 token 的认证方式，它的优点是：
1、适合统一认证的机制，客户端、一方应用、三方应用都遵循一致的认证

机制。
2、token 认证方式对第三方应用接入更适合，因为它更开放，可以使用当前最流行的 Oauth2.0、JWT 等。
3、一般情况服务器端无需存储会话信息，减轻了服务端的压力。分布式系统认证技术方案如下图：
![](media/1677636857876-f4ef4341-bc27-47e1-b808-7ad8cd4a4a54.jpeg.jpg)
流程描述：

1. 用户通过接入方（应用）登录，接入方采取 OAuth2.0 方式在统一认证服务(UAA)中认证。
2. 认证服务(UAA)调用验证该用户的身份是否合法，并获取用户权限信息。认证服务(UAA)获取接入方权限信息，并验证接入方是否合法。
3. 若登录用户以及接入方都合法，认证服务生成 jwt 令牌返回给接入方，其中 jwt 中包含了用户权限及接入方权限。
4. 后续，接入方携带 jwt 令牌对 API 网关内的微服务资源进行访问。
5. API 网关对令牌解析、并验证接入方的权限是否能够访问本次请求的微服务。
6. 如果接入方的权限没问题，API 网关将原请求 header 中附加解析后的明文 Token，并将请求转发至微服务。
7. 微服务收到请求，明文 token 中包含登录用户的身份和权限信息。因此后

续微服务自己可以干两件事：1，用户授权拦截（看当前用户是否有权访问该资源）2，将用户信息存储进当前线程上下文（有利于后续业务逻辑随时 获取当前用户信息）。
流程所涉及到 UAA 服务、API 网关这两个组件职责如下：

   - 统一认证服务(UAA)

它承载了 OAuth2.0 接入方认证、登入用户的认证、授权以及生成令牌的职责，完成实际的用户认证、授权功能。

   - API 网关

作为系统的唯一入口，API 网关为接入方提供定制的 API 集合，它可能还具有其它职责，如身份验证、监控、负载均衡、缓存等。API 网关方式的核心要点是，所有的接入方和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。

# OAuth2.0
### Oauth2.0 介绍

OAuth（开放授权）是一个开放标准，允许用户授权第三方应用访问他们存储在另外服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。OAUTH 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 OAUTH 的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 OAUTH 是安全的，oAuth 是 Open Authorization 的简写，目前的版本是 2.0 版。

### Oauth2 认证例子

下边分析一个 Oauth2 认证的例子，通过例子去理解 OAuth2.0 协议的认证流程，本例子是登录简书网站使用微信认证的过程，这个过程的简要描述如下：用户借助微信认证登录简书网站，用户就不用单独在简书注册用户，怎么样算认证成功呢？简书网站需要成功从微信获取用户的身份信息则认为用户认证成功，那如何从微信获取用户的身份信息？用户信息的拥有者是用户本人，微信需要经过用户的同意方可为简书网站生成令牌，简书网站拿此令牌方可从微信获取用户

的信息。

1. 客户端请求第三方授权

用户进入简书的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。
![](media/1677636859567-543c931d-74fc-4343-b276-5ec64a1f051d.png)
点击“微信”出现一个二维码，此时用户扫描二维码，开始给简书授权。
![](media/1677636860180-13083a83-5dd9-411d-b717-3b560a23cd68.png)

1. 资源拥有者同意给客户端授权

资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权简书访问自己的微信数据，用户点击“同意”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到简书的网站。
![](media/1677636861104-c40979cf-9e08-4f91-a08f-315f3834348c.png)

1. 客户端获取到授权码，请求认证服务器申请令牌

此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。

1. 认证服务器向客户端响应令牌

微信认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在简书看到已经登录成功。

1. 客户端请求资源服务器的资源

客户端携带令牌访问资源服务器的资源。简书网站携带令牌请求访问微信服务器获取用户的基本信息。

1. 资源服务器返回受保护资源

资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。以上认证授权详细的执行流程如下：


![](media/1677636861763-a48e9d96-5a51-40a5-a600-80601bc11dee.jpeg.jpg)
通过上边的例子我们大概了解了 OAauth2.0 的认证过程，下边我们看
OAuth2.0 认证流程：
![](media/1677636862693-41971a47-69c3-4ef5-a8fd-82a14101cb11.png)
(A)用户打开客户端以后，客户端要求用户给予授权。 (B)用户同意给予客户端授权。
(C)客户端使用上一步获得的授权，向认证服务器申请令牌。
(D)认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 (E)客户端使用令牌，向资源服务器申请获取资源。
(F)资源服务器确认令牌无误，同意向客户端开放资源。

OAuth2.0 包括以下角色：
1、客户端
本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：移动客户端、Web 客户端、微信客户端等。
2、资源拥有者
通常为用户，也可以是应用程序，即该资源的拥有者。
3、授权服务器（认证服务器）
用于服务提供商对资源拥有者的身份进行认证，对访问资源进行授权，认证成功后会给客户端颁发令牌（access_token），作为客户端访问资源服务器的凭证。本例为微信的认证服务器。
4、资源服务器
存储资源的服务器，本例子为微信存储的用户信息。
现在还有一个问题，服务提供商能允许随便一个客户端就接入到它的授权服务器吗？答案是否定的，服务提供商会给准入的接入方一个身份，用于接入的凭证：
**client_id**：客户端标识 **client_secret**：客户端秘钥
因此，准确来说，授权服务器对两种 OAuth2.0 中的两个角色进行认证授权，分别是资源拥有者、客户端。

### Oauth2 名词定义

###### Third-party application
第三方应用程序，又称"客户端"（client），如上例中的简书网站。
###### HTTP service
HTTP 服务提供商，简称"服务提供商"，如上例中的微信。
###### Resource Owner
资源所有者，称"用户"（user）。
###### User Agent
用户代理，如浏览器,移动端等。
###### Authorization server
认证服务器，即服务提供商专门用来处理认证的服务器。
###### Resource server
资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，

可以是同一台服务器，也可以是不同的服务器。
### Oauth2 四种授权模式

客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。
授权码模式（authorization code）简化模式（implicit）
密码模式（resource owner password credentials）客户端模式（client credentials）
后面会对它们进行详细讲解。

   1. Spring Cloud Security OAuth2

## 环境介绍

Spring-Security-OAuth2 是对 OAuth2 的一种实现， 并且跟 Spring Security 相辅相成，与 Spring Cloud 体系的集成也非常便利。接下来，我们需要对它进行学习，最终使用它来实现我们设计的分布式认证授权解决方案。
OAuth2.0 的服务提供方涵盖两个服务，即授权服务（Authorization Server，也即认证服务） 和资源服务（ Resource Server ）， 使用 Spring Security OAuth2.0 的时候，可以选择把它们放在同一个应用中实现，也可以选择建立使 用同一个授权服务的多个资源服务。
授权服务 (Authorization Server）应包含对接入端以及登入用户的合法性进行验证并颁发 token 等功能，对令牌的请求端点由 Spring MVC 控制器进行实现，下面是配置一个认证服务必须要实现的 endpoints：

- AuthorizationEndpoint 用来作为请求者获得授权的服务，默认

URL： /oauth/authorize 。

- TokenEndpoint 用来作为请求者获得令牌（Token）的服务。默认 URL：

/oauth/token 。
资源服务 (Resource Server)，应包含对资源的保护功能，对非法请求进行拦截，对请求中 token 进行解析鉴权等，下面的过滤器用于实现 OAuth 2.0 资源服务：

- OAuth2AuthenticationProcessingFilter 用来对请求给出的身份令牌

解析鉴权。
![](media/1677636864228-b755ef0a-1fd2-44fa-b873-598ab041e5ad.jpeg.jpg)本课程分别创建 uaa 授权服务（也可叫认证服务）和 order 订单资源服务。
认证流程如下：
1、客户端请求 UAA 授权服务进行认证。
2、认证通过后由 UAA 颁发令牌。
3、客户端携带令牌 Token 请求资源服务。
4、资源服务校验令牌的合法性，合法即返回资源信息。
## 环境搭建

##### 父工程

新建一个父工程 distributed-security-demo，引入以下依赖：
<**parent**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-parent</**artifactId**>
<**version**>2.1.6.RELEASE</**version**>
</**parent**>
<**dependencyManagement**>
<**dependencies**>
<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-dependencies</**artifactId**>
<**version**>Greenwich.RELEASE</**version**>
<**type**>pom</**type**>
<**scope**>import</**scope**>
</**dependency**>
<**dependency**>
<**groupId**>com.alibaba</**groupId**>
<**artifactId**>fastjson</**artifactId**>
<**version**>1.2.78</**version**>
</**dependency**>

<**dependency**>

<**groupId**>org.springframework.security.oauth.boot</**groupId**>
<**artifactId**>spring-security-oauth2- autoconfigure</**artifactId**>
<**version**>2.1.3.RELEASE</**version**>
</**dependency**>

</**dependencies**>
</**dependencyManagement**>



##### 创建注册中心

1. 引入依赖

<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-starter-netflix-eureka- server</**artifactId**>
</**dependency**>

1. 添加配置

**spring**: **application**:
**name**: discovery-server
**eureka**: **instance**:
**hostname**: localhost
**client**:
**register-with-eureka**: **false **_# 是否将自己注册到 eureka 服务中,单节点运行时为 false,多节点运行时为 true_
**fetch-registry**: **false **_#是否从 eureka 中获取注册信息,单节点运行时为_
_false,多节点运行时为 true_
**service-url**: **defaultZone**:
http://${**eureka.instance.hostname**}:${**server.port**}/eureka/
**server**: **port**: 8761

1. 添加启动类

@SpringBootApplication @EnableEurekaServer
**public class **DiscoveryServer {
**public static void **main(String[] args) { SpringApplication._run_(DiscoveryServer.**class**, args);
}
}

         1. 创建UAA 授权服务工程

#### 引入依赖

在父工程下新建模块 uaa-service，并引入以下依赖：
<**dependencies**>
<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-starter-netflix-eureka- client</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-web</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-jdbc</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>mysql</**groupId**>
<**artifactId**>mysql-connector-java</**artifactId**>
<**version**>8.0.27</**version**>
</**dependency**>
<**dependency**>
<**groupId**>org.projectlombok</**groupId**>
<**artifactId**>lombok</**artifactId**>
</**dependency**>

<**dependency**>
<**groupId**>org.springframework.security.oauth.boot</**groupId**>
<**artifactId**>spring-security-oauth2- autoconfigure</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>com.alibaba</**groupId**>
<**artifactId**>fastjson</**artifactId**>
</**dependency**>
</**dependencies**>



#### 添加配置

新建 application.yml 文件，添加以下配置：
**server**: **port**: 9090
**spring**: **application**:
**name**: uaa-service
**datasource**:
**url**: jdbc:mysql://192.168.10.207:3306/user-db?useUnicode=true
**username**: root
**password**: 123456
**driver-class-name**: com.mysql.cj.jdbc.Driver
**eureka**: **client**:
**service-url**:
**defaultZone**: http://localhost:8761/eureka/
**instance**:
**prefer-ip-address**: **true**



#### 添加启动类

@SpringBootApplication
**public class **UaaApplication {
**public static void **main(String[] args) { SpringApplication._run_(UaaApplication.**class**, args);
}
}

#### 创建 Model 对象
新建 UserDto 对象
@Data
**public class **UserDto { **private **String **id**; **private **String **username**; **private **String **password**; **private **String **fullname**; **private **String **mobile**;
}
新建 PermissionDto 对象
@Data
**public class **PermissionDto {

**private **String **id**; **private **String **code**;
**private **String **description**; **private **String **url**;
}

#### 创建Dao

新建 Dao 类用于从数据库查询用户信息。
@Repository
**public class **UserDao { @Resource
JdbcTemplate **jdbcTemplate**;

_//根据账号查询用户信息_
**public **UserDto getUserByUsername(String username) {
String sql = **"select id,username,password,fullname,mobile from t_user where username = ?"**;
_//连接数据库查询用户_
List<UserDto> list = **jdbcTemplate**.query(sql, **new**
Object[]{username}, **new **BeanPropertyRowMapper<>(UserDto.**class**));
**if **(list != **null **&& list.size() == 1) {
**return **list.get(0);
}
**return null**;
}

_//根据用户 id 查询用户权限_
**public **List<String> findPermissionsByUserId(String userId) { String sql = **"SELECT **_* _**FROM t_permission WHERE id IN(\n" **+
**"\n" **+
**"SELECT permission_id FROM t_role_permission WHERE role_id IN(\n" **+
**" SELECT role_id FROM t_user_role WHERE user_id = ? \n"**
+
**")\n" **+
**")\n"**;

List<PermissionDto> list = **jdbcTemplate**.query(sql, **new **Object[]{userId}, **new **BeanPropertyRowMapper<>(PermissionDto.**class**));
List<String> permissions = **new **ArrayList<>(); list.forEach(c -> permissions.add(c.getCode())); **return **permissions;
}
}

#### 创建Service

定义查询获取 UserDetails 信息的 Service 类 ， 该 类 需 要 实 现
UserDetailsService 接口，重写 loadUserByUsername()方法。
@Service
**public class **SpringDataUserDetailsService **implements**
UserDetailsService { @Resource UserDao **userDao**;
_//根据 账号查询用户信息_
@Override
**public **UserDetails loadUserByUsername(String username) **throws**
UsernameNotFoundException {
_//将来连接数据库根据账号查询用户信息_
UserDto userDto = **userDao**.getUserByUsername(username); **if**(userDto == **null**){
_//如果用户查不到，返回 null，由 provider 来抛出异常_
**return null**;
}
_//根据用户的 id 查询用户的权限_
List<String> permissions =
**userDao**.findPermissionsByUserId(userDto.getId());
_//将 permissions 转成数组_
String[] permissionArray = **new **String[permissions.size()]; permissions.toArray(permissionArray);
_//将 userDto 转成 json_
String principal = JSON._toJSONString_(userDto); UserDetails userDetails =
User._withUsername_(principal).password(userDto.getPassword())
.authorities(permissionArray).build();
**return **userDetails;
}
}
![](media/1677636869524-62063bb2-f838-40b8-bcfc-75ef80900017.png)uaa-service 工程结构如下：

##### 创建资源服务工程

本工程为订单服务工程，访问本工程的资源需要认证通过。本工程的目的主要是测试认证授权的功能，所以不涉及具体相关业务。

#### 引入依赖

在父工程下新建 order-service，并引入如下依赖：
<**dependencies**>
<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-starter-netflix-eureka-

client</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-web</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.projectlombok</**groupId**>
<**artifactId**>lombok</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>com.alibaba</**groupId**>
<**artifactId**>fastjson</**artifactId**>
</**dependency**>

<**dependency**>
<**groupId**>org.springframework.security.oauth.boot</**groupId**>
<**artifactId**>spring-security-oauth2- autoconfigure</**artifactId**>
</**dependency**>

</**dependencies**>

#### 添加配置

**server**: **port**: 9091
**spring**: **application**:
**name**: order-service
**eureka**: **client**:
**service-url**:
**defaultZone**: http://localhost:8761/eureka/
**instance**:
**prefer-ip-address**: **true**

#### 添加启动类

@SpringBootApplication
**public class **OrderApplication {
**public static void **main(String[] args) { SpringApplication._run_(OrderApplication.**class**, args);
}
}
![](media/1677636871020-ae0b539a-62f8-44dc-be44-cc18ca528c28.png)order-service 工程目录结构如下：

## Security 配置

spring security 提供了用户名密码登录、退出、会话管理等认证功能，只需要配置即可使用。在 uaa-service 的 config 包下定义 WebSecurityConfig，安全配置的内容包括：用户信息、密码编码器、安全拦截机制。  @Configuration
**public class **WebSecurityConfig **extends**
WebSecurityConfigurerAdapter {

@Bean
**public **PasswordEncoder passwordEncoder() {
**return new **BCryptPasswordEncoder();
}

@Bean @Override
**protected **AuthenticationManager authenticationManager() **throws**
Exception {
**return super**.authenticationManager();
}

@Override
**protected void **configure(HttpSecurity http) **throws **Exception { http
_//屏蔽跨域防护_
.csrf().disable()
_//对请求做授权处理_
.authorizeRequests()
_//登录路径放行_
.antMatchers(**"/login"**).permitAll()
_//其他路径都要拦截_
.anyRequest().authenticated()
_//允许表单登录_
.and().formLogin()
_//登出_
.and().logout().permitAll();
}
}
**注意**：此处在配置 PasswordEncoder 时使用的是
BcryptPasswordEncoder ，那么数据库中存储的密码必须是采用 Bcrypt 方式
加密后的密码，加密的密码获取方式可参考如下代码：
@SpringBootTest @RunWith(SpringJUnit4ClassRunner.**class**) **public class **TestBCrypt {

@Test
**public void **testPassword(){
_//对密码进行加密_
String hashpw = BCrypt._hashpw_(**"123"**, BCrypt._gensalt_()); System.**_out_**.println(hashpw);
_//校验密码_
**boolean **checkpw = BCrypt._checkpw_(**"123"**,
**"$2a$10$aFsOFzujtPCnUCUKcozsHux0rQ/3faAHGFSVb9Y.B1ntpmEhjRtru"**); **boolean **checkpw2 = BCrypt._checkpw_(**"123"**,
**"$2a$10$HuClcUqr/FSLmzSsp9SHqe7D51Keu1sAL7tUAAcb..FyILiLdFKYy"**);
System.**_out_**.println(checkpw); System.**_out_**.println(checkpw2);
}
}

## 授权服务器配置

配置一个授权服务，需要考虑几种授权类型（Grant Type），不同的授权类型为客户端（Client）提供了不同的获取令牌（Token）方式，为了实现并确定这几种授权，需要配置使用 ClientDetailsService 和 TokenService 来开启或者禁用这几种授权机制。到这里就请注意了，不管你使用什么样的授权类型
（Grant Type），每一个客户端（Client）都能够通过明确的配置以及权限来实现 不 同 的 授 权 访 问 机 制 。 这 也 就 是 说 ， 假 如 你 提 供 了 一 个 支 持 "client_credentials"的授权方式，并不意味着客户端就需要使用这种方式来获得授权。下面是几种授权类型的列表，具体授权机制的含义可以参见 RFC6749(中文版本)：
authorization_code：授权码类型。 implicit：简化授权类型。     password：资源所有者（即用户）密码类型。
client_credentials：客户端凭据（客户端 ID 以及 Key）类型。 refresh_token：通过以上授权获得的刷新令牌来获取新的令牌。

##### 创建AuthorizationServer

在 uaa-service 的 config 包下面创建 AuthorizationServer 类，此类需要继承 AuthorizationServerConfigurerAdapter 并添加@ EnableAuthorizationServer 注解，以进行 Oauth2.0 授权服务器的配置。 @Configuration
@EnableAuthorizationServer
**public class **AuthorizationServer **extends**
AuthorizationServerConfigurerAdapter {

}
AuthorizationServerConfigurerAdapter 要求配置以下几个类，这几个
类是由 Spring 创建的独立的配置对象，它们会被 Spring 传入

AuthorizationServerConfigurer 中进行配置。
**public class **AuthorizationServerConfigurerAdapter **implements**
AuthorizationServerConfigurer { @Override
**public void **configure(AuthorizationServerSecurityConfigurer security) **throws **Exception {
}
@Override
**public void **configure(ClientDetailsServiceConfigurer clients)
**throws **Exception {
}
@Override
**public void **configure(AuthorizationServerEndpointsConfigurer endpoints) **throws **Exception {
}
}

- ClientDetailsServiceConfigurer ： 用 来 配 置 客 户 端 详 情 服 务

（ClientDetailsService），如配置客户端 id(client_id)资源 id、客户端密钥 (secrect)、授权方式、scope 等,可以基于内存或 jdbc。(可以理解为是对浏览器向授权服务器获取授权码或令牌时需要提交的参数配置)，其实就是对客户端的参数配置，在客户端获取授权码或者获取 Token 的 URL 请求中就需要带上这些客户端参数。比如：
![](media/1677636873255-2f8eeecb-5735-4723-a699-b7be8427890e.jpeg.jpg)

- AuthorizationServerEndpointsConfigurer：配置令牌的访问端点 url 和令牌服务，如配置如何管理授权码(内存或 jdbc)，如何管理令牌(存储方式，有效时间等等)。
- AuthorizationServerSecurityConfigurer：用来配置令牌端点的安全约束，如配置对获取授权码，检查 token 等某些路径进行放行。

##### 配置客户端详细信息

ClientDetailsServiceConfigurer 能够使用内存或者 JDBC 来实现客户端详情服务（ClientDetailsService），ClientDetailsService 负责查找 ClientDetails，而 ClientDetails 有几个重要的属性如下列表：

- clientId：（必须的）用来标识客户的 Id。
- secret：（需要值得信任的客户端）客户端安全码，如果有的话。
- scope：用来限制客户端的访问范围，如果为空（默认）的话，那么客户端拥有全部的访问范围。
- authorizedGrantTypes：此客户端可以使用的授权方式，可选值：授权码模式:authorization_code；密码模式:password；刷新 token: refresh_token；简化模式: implicit；客户端模式: client_credentials。支持多个用逗号分隔。
- authorities：此客户端可以使用的权限（基于 Spring Security authorities）。客户端详情（ClientDetails）能够在应用程序运行的时候进行更新，可以

通过访问底层的存储服务（例如将客户端详情存储在一个关系数据库的表中，就可以使用 JdbcClientDetailsService）或者通过自己实现 ClientRegistrationService 接口（同时也可以实现 ClientDetailsService 接口）来进行管理。
我们暂时使用内存方式存储客户端详情信息，配置如下:
@Override
**public void **configure(ClientDetailsServiceConfigurer clients)
**throws **Exception {
_//使用 in‐memory 存储_
clients.inMemory()
_//配置客户端 id_
.withClient(**"c1"**)
_//配置客户端密钥_
.secret(**new **BCryptPasswordEncoder().encode(**"secret"**))
_//配置客户端可以访问的资源服务 ID_
.resourceIds(**"res1"**)
_//该 client 允许的授权类型_
.authorizedGrantTypes(**"authorization_code"**,

**"password"**,**"client_credentials"**,**"implicit"**,**"refresh_token"**)
_//允许的授权范围，仅仅只是一个标识_
.scopes(**"all"**)
_//为 false 表示跳转到授权页面，为 true 直接不跳转直接发访令牌_
.autoApprove(**false**)
_//注册回调地址_
.redirectUris(**"**[**http://www.baidu.com"**](http://www.baidu.com/));
}

##### 配置令牌管理服务

AuthorizationServerTokenServices 接口定义了一些操作使得你可以对令牌进行一些必要的管理，令牌可以被用来加载身份信息，里面包含了这个令牌的相关权限。在使用这些操作的时候请注意以下几点：

   - 当一个令牌被创建了，你必须对其进行保存，这样当一个客户端使用这个令牌对资源服务进行请求的时候才能够引用这个令牌。
   - 当一个令牌是有效的时候，它可以被用来加载身份信息，里面包含了这个令牌的相关权限。

当你自己创建 AuthorizationServerTokenServices 这个接口的实现时，你可能需要考虑一下使用 DefaultTokenServices 这个类，里面包含了一些有用实现，可以使用它来修改令牌的格式和令牌的存储。默认的，当它尝试创建一个令牌的时候，是使用随机值来进行填充的，除了持久化令牌是委托一个 TokenStore 接口来实现以外， 这个类几乎帮你做了所有的事情。并且 TokenStore 这个接口有一个默认的实现，它就是 InMemoryTokenStore ，如其命名，所有的令牌是被保存在了内存中。除了使用这个类以外，还可以使用一些其他的预定义实现，下面有几个版本，它们都实现了 TokenStore 接口：

   - InMemoryTokenStore：这个版本的实现是被默认采用的，它可以完美的工作在单服务器上（即访问并发量压力不大的情况下，并且它在失败的时候不会进行备份），大多数的项目都可以使用这个版本的实现来进行尝试，可以在开发的时候使用它来进行管理，因为不会被保存到磁盘中，所以更易于调试。
   - JdbcTokenStore：这是一个基于 JDBC 的实现版本，令牌会被保存进关系型数据库。使用这个版本的实现时， 可以在不同的服务器之间共享令牌信息，使用这个版本的时候请注意把"spring-jdbc"这个依赖加入到 classpath 当中。
   - JwtTokenStore：这个版本的全称是 JSON Web Token（JWT），它可以把令牌相关的数据进行编码（因此对于后端服务来说，它不需要进行存储，这是一个重大优势），但是它有一个缺点，那就是撤销一个已经授权令牌将会非常困难，所以它通常用来处理一个生命周期较短的令牌以及撤销刷新令牌（refresh_token）。 另外一个缺点就是如果

加入了比较多用户凭证信息，这个令牌占用的空间会比较大。 JwtTokenStore 不会保存任何数据，但是它在转换令牌值以及授权信息方面与 DefaultTokenServices 所扮演的角色是一样的。

1. 定义 TokenConfig

在 config 包下新建一个 TokenConfig 配置类，暂时先使用
InMemoryTokenStore 生成一个令牌。
@Configuration
**public class **TokenConfig {
_/**_
_* 配置令牌的存储方式_
_*/_
@Bean
**public **TokenStore tokenStore(){
**return new **InMemoryTokenStore();
}
}

1. 配置令牌管理服务

在 AuthorizationServer 类中定义 AuthorizationServerTokenServices。
@Resource
**private **TokenStore **tokenStore**; @Resource
**private **ClientDetailsService **clientDetailsService**;

@Bean
**public **AuthorizationServerTokenServices tokenService(){ DefaultTokenServices services = **new **DefaultTokenServices(); services.setClientDetailsService(**clientDetailsService**); services.setTokenStore(**tokenStore**);
_//access_token 有效期 2 小时_
services.setAccessTokenValiditySeconds(60*60*2);
_//refresh token 有效期 3 天_
services.setRefreshTokenValiditySeconds(60*60*72);
_//是否产生 refresh token _services.setSupportRefreshToken(**true**); **return **services;
}

##### 令牌访问端点配置

AuthorizationServerEndpointsConfigurer 这个对象的实例可以完成令
牌服务以及令牌 endpoint 配置。
###### 配置授权类型（Grant Types）
AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型（Grant Types）:

- authenticationManager：认证管理器，当你选择了资源所有者密码

（password）授权类型的时候，请设置这个属性注入一个
AuthenticationManager 对象。

- userDetailsService：如果你设置了这个属性的话，那说明你有一个自己的 UserDetailsService 接口的实现，或者你可以把这个东西设置到全局域上面去（例如 GlobalAuthenticationManagerConfigurer 这个配置对象），当你设置了这个之后，那么 "refresh_token" 即刷新令牌授权类型模式的流程中就会包含一个检查步骤，用来确保这个账号是否仍然有效。
- authorizationCodeServices：这个属性是用来设置授权码服务的（即 AuthorizationCodeServices 的实例对象），主要用于 "authorization_code" 授权码类型模式。 提供了 InMemoryAuthorizationCodeServices 基于内存和基于数据库 JdbcAuthorizationCodeServices 的授权码存储方案，如果是基于 JDBC那么我们需要提供存储授权码的表“oauth_code”。
- implicitGrantService：这个属性用于设置简化授权模式，用来管理简化授权模式的状态。
- tokenGranter：当你设置了这个东西（即 TokenGranter 接口实现），那么 授权将会交由你来完全掌控，并且会忽略掉上面的这几个属性，这个属性一 般是用作拓展用途的，即标准的四种授权模式已经满足不了你的需求的时候，才会考虑使用这个。
###### 配置授权端点的 URL（Endpoint URLs）
AuthorizationServerEndpointsConfigurer 这个配置对象有一个叫做
pathMapping() 的方法用来配置端点 URL 链接，它有两个参数：第一个参数：String 类型的，这个端点 URL 的默认链接。
第二个参数：String 类型的，你要进行替代的 URL 链接。
以上的参数都将以 "/" 字符为开始的字符串，框架的默认 URL 链接如下列表，可以作为这个 pathMapping() 方法的第一个参数：

- /oauth/authorize：授权端点。
- /oauth/token：令牌端点。
- /oauth/confirm_access：用户确认授权提交端点。
- /oauth/error：授权服务错误信息端点。
- /oauth/check_token：用于资源服务访问的令牌解析端点。
- /oauth/token_key：提供公有密匙的端点，如果你使用 JWT 令牌的话。需要注意的是授权端点这个 URL 应该被 Spring Security 保护起来只供授

权用户访问。
继续在 AuthorizationServer 类中配置令牌访问端点，参考代码如下：
@Resource
**private **AuthenticationManager **authenticationManager**; @Resource
**private **AuthorizationCodeServices **authorizationCodeServices**;

_/**_
_* 配置令牌访问端点_
_*/_
@Override
**public void **configure(AuthorizationServerEndpointsConfigurer endpoints) **throws **Exception {
endpoints
_//密码模式需要_
.authenticationManager(**authenticationManager**)
_//授权码模式需要_
.authorizationCodeServices(**authorizationCodeServices**)
_//令牌管理服务_
.tokenServices(tokenService())
_//允许使用 post 提交方式来访问令牌_
.allowedTokenEndpointRequestMethods(HttpMethod.**_POST_**);
}

_/**_

- _设置授权码模式的授权码如何存取，暂时采用内存方式_

_*/_
@Bean
**public **AuthorizationCodeServices authorizationCodeServices() {
**return new **InMemoryAuthorizationCodeServices();
}

##### 令牌端点的安全约束

AuthorizationServerSecurityConfigurer ： 用来配置令牌端点(Token Endpoint)的安全约束，在 AuthorizationServer 中添加如下配置：

_/**_

- _配置访问令牌端点的安全策略_

_*/_
@Override
**public void **configure(AuthorizationServerSecurityConfigurer security) **throws **Exception {
security
_//公开端点/oauth/token_key 的访问权限_
.tokenKeyAccess(**"permitAll()"**)
_//公开端点/oauth/check_token 的访问权限_
.checkTokenAccess(**"permitAll()"**)
_//允许表单认证来申请令牌_
.allowFormAuthenticationForClients();
}

1. tokenkey 这个 endpoint 当使用 JwtToken 且使用非对称加密时，资源服务用于获取公钥而开放的，这里指这个 endpoint 完全公开。
2. checkToken 这个 endpoint 完全公开 。
3. 允许表单认证。

**授权服务配置总结**：授权服务配置分成三大块，可以关联记忆。既然要完成认证，它首先得知道客户端信息从哪儿读取，因此要进行客户端详情配置。既然要颁发 token，那必须得定义 token 的相关 endpoint，以及 token 如何存取，以及客户端支持哪些类型的 token。既然暴露除了一些 endpoint，那对这些 endpoint 可以定义一些安全上的约束等。
## 授权码模式
下图是授权码模式交互图：
![](media/1677636876757-fff75143-d3e1-45a4-ab89-2642881bcb5b.jpeg.jpg)

   1. 资源拥有者打开客户端，客户端要求资源拥有者给予授权，浏览器重定向到授权服务器，重定向时会附加客户端的身份信息，如：

/oauth/authorize?client_id=c1&response_type=code&scope=all&redire ct_u[ri=h](http://www.baidu.com/)tt[p://www](http://www.baidu.com/).[baidu.com](http://www.baidu.com/)	（**GET 请求**）
参数列表如下：
client_id：客户端准入标识。 response_type：授权码模式固定为 code。 scope：客户端权限。
redirect_uri：跳转 uri，当授权码申请成功后会跳转到此地址，并在后边带上 code 参数（授权码）。
![](media/1677636877753-6213d884-2a93-487e-8ec9-605b97d238c9.png)

   1. 浏览器出现向授权服务器授权页面，之后将用户同意授权。

![](media/1677636878320-1c07f6b5-a80f-4986-a7bf-edeb3d729f19.jpeg.jpg)

   1. 授权服务器将授权码（ AuthorizationCode）转经浏览器发送给

client(通过 redirect_uri)。
![](media/1677636878990-9210c3ee-f445-47a3-9a20-2e663896b8e6.png)

   1. 客户端拿着授权码向授权服务器索要访问 access_token，请求如下：/oauth/token **（POST 请求）**

参数列表如下
client_id：客户端准入标识，示例中为 c1。 client_secret：客户端秘钥，示例中为 secret。

grant_type：授权类型，填写 authorization_code，表示授权码模式 。
code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。
redirect_uri：申请授权码时的跳转 url，一定和申请授权码时用的 redirect_uri 一致，示例中为 [http://www.baidu.com](http://www.baidu.com/) 。
![](media/1677636880612-1d38c543-1489-49a4-94f3-1223e7a8d183.jpeg.jpg)
这种模式是四种模式中最安全的一种模式。一般用于 client 是 Web 服务器端应用或第三方的原生 App 调用资源服务的时候。因为在这种模式中 access_token 不会经过浏览器或移动端的 App，而是直接从服务端去交换，这样就最大限度的减小了令牌泄漏的风险。

   1. client 拿到令牌后可以访问：/oauth/check_token (GET 请求)对令牌进行校验：

![](media/1677636881525-238f26f3-3139-4250-9d5b-3fdffee69902.jpeg.jpg)


## 简化模式

![](media/1677636882662-0902908c-4f6e-495f-b197-08286ec599ab.jpeg.jpg)下图是简化模式交互图：

1. 资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会附加客户端的身份信息。如：

/oauth/authorize?client_id=c1&response_type=token&scope=all&r edirect_uri=[http://www.baidu.com](http://www.baidu.com/)	**（get 请求）**
参数描述同授权码模式，注意 response_type=token，说明是简化模式。

1. ![](media/1677636883133-cd49b74f-57ff-46a4-8dd5-a87267ff6474.jpeg.jpg)浏览器出现向授权服务器授权页面，之后将用户同意授权。
2. 授权服务器将授权码将令牌（access_token）以 Hash 的形式存放在重定向 uri 的 fragment 中发送给浏览器。

![](media/1677636884227-d38bd36a-044c-4f66-8847-86d8207017ec.jpeg.jpg)
注：fragment 主要是用来标识 URI 所标识资源里的某个资源，在 URI 的末尾通过（#）作为 fragment 的开头，其中 # 不属于 fragment 的值。如 https://domain/index#L18 这个 URI 中 L18 就是 fragment 的值。只需要知道 js 通过响应浏览器地址栏变化的方式能获取到 fragment 就行了。
一般来说，简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法接收授权码。
## 密码模式
下图是密码模式交互图：
![](media/1677636884659-89390946-8bdb-49de-93ef-cdcfc1c3d3c5.jpeg.jpg)

1. 资源拥有者将用户名、密码发送给客户端。
2. 客户端拿着资源拥有者的用户名、密码向授权服务器请求令牌

（access_token），请求如下：**（POST 请求）**
/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=pass word&username=zhangsan&password=123
参数列表如下：  client_id：客户端准入标识。 client_secret：客户端秘钥。
grant_type：授权类型，填写 password 表示密码模式 username：资源拥有者用户名。      password：资源拥有者密码。

1. 授权服务器将令牌（access_token）发送给 client

![](media/1677636885721-d6907850-3cb9-416b-872c-b25eb3ee7aaa.png)这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了 client，因此这就说明这种模式只能用于 client 是我们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生 App 或第一方单页面应用。
## 客户端模式
![](media/1677636886081-6df035f1-96bf-48f0-b133-5fb5b0087afc.jpeg.jpg)

1. 客户端向授权服务器发送自己的身份信息，并请求令牌（access_token）
2. 确认客户端身份无误后，将令牌（access_token）发送给 client，请求如下：

/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=cl ient_credentials	**（POST 请求）**
参数列表如下：  client_id：客户端准入标识。 client_secret：客户端秘钥。
grant_type：授权类型，填写 client_credentials 表示客户端模式。
这种模式是最方便但最不安全的模式。这要求我们对 client 完全的信任，而 client 本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。

![](media/1677636887102-9dd945d1-b196-430e-8715-bc9475ca350b.jpeg.jpg)

## 资源服务测试

##### 编写资源

在资源服务 order-service 的 controller 包下编写 OrderController，此 controller 表示订单资源的访问类：
@RestController @RequestMapping(**"/order"**) **public class **OrderController {
@RequestMapping(value = **"/r1"**) @PreAuthorize(**"hasAnyAuthority('p1')"**) **public **String resourceOne(){
**return "访问资源 1"**;
}
@RequestMapping(value = **"/r2"**) @PreAuthorize(**"hasAnyAuthority('p2')"**) **public **String resourceTwo(){
**return "访问资源 2"**;
}
}

##### 资源服务器配置

资源服务器配置类上需要添加@EnableResourceServer 注解和 @Configuration 注解，并且必须使用 ResourceServerConfigurer 这个配置对象来进行配置（可以选择继承自 ResourceServerConfigurerAdapter 然后覆写其中的方法，参数就是这个对象的实例），下面是一些可以配置的属性：
###### ResourceServerSecurityConfigurer 中主要包括：

- tokenServices：ResourceServerTokenServices 类的实例，用来实现令牌验证的服务。
- tokenStore：TokenStore 类的实例，指定令牌如何访问（校验）。
- resourceId：这个资源服务的 ID，这个属性是可选的，但是推荐设置并在授权服务中进行验证。
- 其他的拓展属性例如 tokenExtractor 令牌提取器用来提取请求中的令牌。

**HttpSecurity **配置这个与 Spring Security 类似：

- 请求匹配器，用来设置需要进行保护的资源路径，默认的情况下是保护资源服务的全部路径。
- 通过 http.authorizeRequests()来设置受保护资源的访问规则。
- 其他的自定义权限保护规则通过 HttpSecurity 来进行配置。

@EnableResourceServer 注解自动增加了一个类型为
OAuth2AuthenticationProcessingFilter 的过滤器链。
在 order-service 的 config 包下新建 ResourceServerConfig 配置类，参考代码如下：
@Configuration @EnableResourceServer
@EnableGlobalMethodSecurity(prePostEnabled = **true**) **public class **ResourceServerConfig **extends **ResourceServerConfigurerAdapter {

_/*配置资源 id ,对应 oauth_client_details 表中配置的 resourceIds_
_*一个资源 ID 可以对应一个资源服务器，如果 Token 中不包含该资源 ID 就无法访问该资源服务器_
_*/_
**public final static **String **_RESOURCE_ID _**= **"res1"**;

_/**_
_* 资源服务器安全性配置_
_*/_
@Override
**public void **configure(ResourceServerSecurityConfigurer resources) **throws **Exception {
resources
_//资源 ID，请求中的 Token 必须有用该资源 ID 的访问权限才可以访问该_
_资源服务器_
.resourceId(**_RESOURCE_ID_**)
_//验证令牌的服务，令牌验证通过才允许获取资源，使用远程校验_
.tokenServices(tokenService());
}

_/**_
_* 配置 Security 安全访问控制_
_*/_
@Override
**public void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
_//校验 scope 必须为 all ， 对应认证服务的客户端详情配置的 scope_
.antMatchers(**"/**"**).access(**"#oauth2.hasScope('all')"**)
_//关闭跨域伪造检查_
.and().csrf().disable()
_//把 session 设置为无状态，意思是使用了 token，那么 session 不再做数据的记录_
.sessionManagement().sessionCreationPolicy(SessionCreat ionPolicy.**_STATELESS_**);
}

}



##### 验证 token

ResourceServerTokenServices 是组成授权服务的另一半，如果你的授权服务和资源服务在同一个应用程序上的话，你可以使用
DefaultTokenServices ，这样的话，你就不用考虑关于实现所有必要的接口 的一致性问题。如果你的资源服务器是分离开的，那么你就必须要确保能够有匹配授权服务提供的 ResourceServerTokenServices，它知道如何对令牌进行解码。
令牌解析方法：使用 RemoteTokenServices 资源服务器通过 HTTP 请

求来解码令牌，每次都请求授权服务器端点/oauth/check_token 使用授权服务的 /oauth/check_token 端点你需要在授权服务将这个端点暴露出去，以便资源服务可以进行访问，这在咱们授权服务配置中已经提到了，我们在授权服务中配置了/oauth/check_token 和 /oauth/token_key 这两个端点，开放了它们的访问权限。
接下来需要在 ResourceServerConfig 中添加 RemoteTokenServices 的配置：
@Bean
**public **ResourceServerTokenServices tokenService(){
_//使用远程服务请求授权服务器校验 token,必须指定校验 token 的 url、 client_id、client_secret_
RemoteTokenServices services = **new **RemoteTokenServices();


services.setCheckTokenEndpointUrl(**"http://localhost:9090/oauth/ch eck_token"**);
services.setClientId(**"c1"**); services.setClientSecret(**"secret"**); **return **services;
}

##### 效果测试

1. 申请令牌

这里使用密码方式来获取令牌：


![](media/1677636889320-f6854358-68fa-4a2c-95a4-2d9f32aaf7cc.png)

1. 请求资源

![](media/1677636890330-8e32d56b-a61c-47a8-bd17-6044987bae5e.jpeg.jpg)按照 oauth2.0 协议要求，请求资源需要在 header 中携带 token，如下： token 的参数名称为：Authorization，值为：Bearer token 值。

   1. JWT 令牌

## JWT 令牌介绍
通过上边的测试我们发现，当资源服务和授权服务不在一起时资源服务使用 RemoteTokenServices 远程请求授权服务验证 token，如果访问量较大将会影响系统的性能。
解决上边问题：令牌采用 JWT 格式即可解决此问题，用户认证通过会得到一个 JWT 令牌，JWT 令牌中已经包括了用户相关的信息，客户端只需要携带 JWT 访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。
###### 什么是 JWT？
JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递 Json 对象，传递的信息经过数字签名可以被验证和信任。JWT 可以使用 HMAC 算法或使用 RSA 的公钥/私钥对来签名，防止被篡改。
JWT 令牌的优点：
1）jwt   基于   json，非常方便解析。 2）可以在令牌中自定义丰富的内容，易扩展。

1. 通过非对称加密算法及数字签名技术，JWT 防止篡改，安全性高。
2. 资源服务使用 JWT 可不依赖认证服务即可完成授权。缺点：

１）JWT 令牌较长，占存储空间比较大。
###### JWT 令牌结构
JWT 令牌由三部分组成， 每部分中间使用点（ . ） 分隔， 比如：

1. yyyyy.zzzzz 。
   - Header

头部包括令牌的类型（即 JWT）及使用的哈希算法（如 HMAC SHA256 或
RSA）。一个例子如下：
下边是 Header 部分的内容
{
"alg": "HS256",
"typ": "JWT"
}
将上边的内容使用Base64Url 编码，得到一个字符串就是 JWT 令牌的第一部分。

   - Payload

第二部分是负载，内容也是一个 json 对象，它是存放有效信息的地方，它可以存放 jwt 提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub
（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。将第二部分负载使用 Base64Url 编码，得到一个字符串就是 JWT 令牌的第二部分。
示例如下：
{
"sub": "1234567890",
"name": "456", "admin": true
}

   - Signature

第三部分是签名，此部分用于防止 jwt 内容被篡改。这个部分使用 base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用 header 中声明签名算法进行签名。
示例如下：
HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secre t)
base64UrlEncode(header)：jwt 令牌的第一部分。 base64UrlEncode(payload)：jwt 令牌的第二部分。 secret：签名所使用的密钥。
## 配置 JWT 令牌服务
在 uaa-service 中配置 jwt 令牌服务，实现生成 jwt 格式的令牌。修改 TokenConfig 中的内容，参考如下：
@Configuration
**public class **TokenConfig {
**private static final **String **_SIGNING_KEY _**= **"hello-jwt"**;

_/**_
_* 配置令牌的存储方式_
_*/_
@Bean
**public **TokenStore tokenStore() {
**return new **JwtTokenStore(tokenConverter());
}

@Bean
**public **JwtAccessTokenConverter tokenConverter() { JwtAccessTokenConverter converter = **new**
JwtAccessTokenConverter();
_//使用对称加密,资源服务器使用该秘钥来验证 _converter.setSigningKey(**_SIGNING_KEY_**); **return **converter;
}
}
修改配置类 AuthorizationServer 中令牌管理服务，添加令牌增强的配置，
参考如下：

@Resource
**private **JwtAccessTokenConverter **jwtAccessTokenConverter**;
_/**_
_* 配置令牌管理服务_
_*/_
@Bean
**public **AuthorizationServerTokenServices tokenService() { DefaultTokenServices services = **new **DefaultTokenServices(); services.setClientDetailsService(**clientDetailsService**); services.setTokenStore(**tokenStore**);
_//配置令牌增强_
**TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();**

**tokenEnhancerChain.setTokenEnhancers(Arrays._asList_(jwtAccessToken Converter));**
**services.setTokenEnhancer(tokenEnhancerChain);**
_//access_token 有效期 2 小时_
services.setAccessTokenValiditySeconds(60 * 60 * 2);
_//refresh token 有效期 3 天_
services.setRefreshTokenValiditySeconds(60 * 60 * 72);
_//支持使用 refresh token 刷新 access token_
services.setSupportRefreshToken(**true**);
**return **services;
}

## 生成 JWT 令牌
使用密码模式请求授权服务获取令牌：

http://localhost:9090/oauth/token
![](media/1677636892419-70c98186-f536-4686-8188-52d095eb3860.png)



## 校验 JWT 令牌
资源服务需要和授权服务拥有一致的签字、令牌服务等：
1、将授权服务中的 TokenConfig 类拷贝到资源服务中
2、屏蔽资源服务原来的令牌服务类
修改后的 ResourceServerConfig 代码如下：

@Configuration @EnableResourceServer
**public class **ResourceServerConfig **extends**
ResourceServerConfigurerAdapter {

**public final static **String **_RESOURCE_ID _**= **"res1"**; **@Resource**
**private TokenStore tokenStore;**

@Override
**public void **configure(ResourceServerSecurityConfigurer resources) **throws **Exception {
resources
_//配置资源 ID_
.resourceId(**_RESOURCE_ID_**)
**.tokenStore(tokenStore);**
}

@Override
**public void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
.antMatchers(**"/**"**).access(**"#oauth2.hasScope('all')"**)
.and().csrf().disable()
.sessionManagement().sessionCreationPolicy(SessionCreat ionPolicy.**_STATELESS_**);
}
}

## 测试校验
使用 JWT 令牌访问资源服务：
![](media/1677636893960-fbcedf35-1e64-4219-a6be-8bd9d9734808.jpeg.jpg)

### 完善示例程序配置

截止目前客户端信息和授权码仍然存储在内存中，生产环境中通过会存储在数据库中，下边完善环境的配置。
## 创建数据库表

**DROP TABLE IF EXISTS **`oauth_client_details`**;**
-- 创建客户端信息表
**CREATE TABLE **`oauth_client_details` **(**
`client_id` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NOT NULL COMMENT **'客户端标识'**,**
`resource_ids` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL COMMENT **'接入资源列表'**,**
`client_secret` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL COMMENT **'客户端秘钥 '**,**
`**scope**` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL,**
`authorized_grant_types` **VARCHAR (**255**) CHARACTER SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL,**
`web_server_redirect_uri` **VARCHAR (**255**) CHARACTER SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL,**
`authorities` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL,**
`access_token_validity` **INT (**11**) NULL DEFAULT NULL,**
`refresh_token_validity` **INT (**11**) NULL DEFAULT NULL,**
`additional_information` LONGTEXT **CHARACTER SET **utf8 **COLLATE **utf8_general_ci **NULL,**
`create_time` **TIMESTAMP (**0**) NOT NULL DEFAULT CURRENT_TIMESTAMP (**0**) ON UPDATE CURRENT_TIMESTAMP (**0**),**
`archived` **TINYINT (**4**) NULL DEFAULT NULL,**
`trusted` **TINYINT (**4**) NULL DEFAULT NULL,**
`autoapprove` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL, PRIMARY KEY (**`client_id`**) USING **BTREE
**) **ENGINE **= **INNODB **CHARACTER**
**SET = **utf8 **COLLATE = **utf8_general_ci **COMMENT = **'接入客户端信息' ROW_FORMAT **= Dynamic;**
-- 插入数据
**INSERT INTO **`oauth_client_details` **VALUES (**'c1'**, **'res1'**, **'$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm'**, **'ROLE_ADMIN,ROLE_USER,ROLE_API'**,**
'client_credentials,password,authorization_code,implicit,refresh_toke n'**, **'[http://www.baidu.com](http://www.baidu.com)'**,**
**NULL, **7200**, **259200**, NULL, **now**(), **0**, **0**, **'false'**);**
**INSERT INTO **`oauth_client_details` **VALUES (**'c2'**, **'res2'**, **'$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm'**, **'ROLE_API'**,**
'client_credentials,password,authorization_code,implicit,refresh_toke n'**, **'[http://www.baidu.com](http://www.baidu.com)'**,**
**NULL, **31536000**, **2592000**, NULL, **now**(), **0**, **0**, **'false'**);**

-- 创建授权码表,用于存储授权码
**DROP TABLE IF EXISTS **`oauth_code`**;**

**CREATE TABLE **`oauth_code` **(**
`create_time` **TIMESTAMP (**0**) NOT NULL DEFAULT CURRENT_TIMESTAMP,**
`code` **VARCHAR (**255**) CHARACTER**
**SET **utf8 **COLLATE **utf8_general_ci **NULL DEFAULT NULL,**
`authentication` **BLOB NULL,**
**INDEX **`code_index` **(**`code`**) USING **BTREE
**) **ENGINE **= **INNODB **CHARACTER**
**SET = **utf8 **COLLATE = **utf8_general_ci ROW_FORMAT **= **Compact**;**

oauth_client_details 表字段解释：
**client_id**：主键，必须唯一，不能为空；用于唯一标识每一个客户端(client)；注册时必须填写(也可以服务端自动生成)，这个字段是必须的，实际应用也有叫 app_key 例如：OaH1heR2E4eGnBr87Br8FHaUFrA2Q0kE8HqZgpdg8Sw。
**resource_ids**：资源 ID，不能为空，用逗号分隔；客户端能访问的资源 id集合，注册客户端时，根据实际需要可选择资源 id，也可以根据不同的额注册流程，赋予对应的额资源 id，例如：order-resource,pay-resource。
**client_secret**：客户端秘钥，不能为空；注册填写或者服务端自动生成，实际 应 用 也 有 叫  app_secret, 必 须 要 有 前 缀 代 表 加 密 方 式 ， 例 如 ：
{bcrypt}gY/Hauph1tqvVWiH4atxteSH8sRX03IDXRIQi03DVTFGzKfz8ZtGi。
**scope**: 授权范围，不可为空；指定 client 的权限范围，比如读写权限，比如移动端还是 web 端权限，例如：read,write / web,mobile。
**authorized_grant_types **： 授权方式， 不可为空； 可选值： 授权码模式:authorization_code,密码模式:password,刷新 token: refresh_token, 简化
模式: implicit: 客户端模式: client_credentials。支持多个用逗号分隔，例如： "implicit","client_credentials","password","authorization_code", "refresh_token"。
**web_server_redirect_uri **： 客户端重定向 uri ； 客户端重定向 uri ， authorization_code 和 implicit 需要该值进行校验，注册时填写，例如： httt://[www.baidu.com](http://www.baidu.com/)。
**authorities**：权限，可为空；指定用户的权限范围，如果授权的过程需要用户登陆，该字段不生效， implicit 和 client_credentials 需要， 例如： ROLE_ADMIN,ROLE_USER。
**access_token_validity**：Token 有效期，可空；设置 access_token 的有效时间(秒),默认(606012,12 小时)，例如：3600。
**refresh_token_validity **： 刷 新 Token 有 效 时 期 ， 可 空 ； 设 置
refresh_token 有效期(秒)，默认(606024*30, 30 填)，例如：7200。
**additional_information**： 附加数据，可空；附加数据，值必须是 json 格式 ，例如：{"key", "value"}。
**autoapprove**：是否默认授权。
## 修改授权服务配置
修改 AuthorizationServer 中关于客户端信息获取和授权码存储的配置。

- 修改客户端配置

@Resource
**private **PasswordEncoder **passwordEncoder**;

_/**_
_* 从数据库读取客户端信息_
_*/_
@Bean
**public **ClientDetailsService clientDetailsService(DataSource dataSource) {
JdbcClientDetailsService service = **new**
JdbcClientDetailsService(dataSource); service.setPasswordEncoder(**passwordEncoder**); **return **service;
}

_/**_
_* 配置客户端详情_
_*/_
@Override
**public void **configure(ClientDetailsServiceConfigurer clients)
**throws **Exception { clients.withClientDetails(**clientDetailsService**);
}




_/**_

- 修改授权码存储配置

_* 设置授权码模式的授权码如何存取_
_*/_
@Bean
**public **AuthorizationCodeServices authorizationCodeServices(DataSource dataSource) {
**return new **JdbcAuthorizationCodeServices(dataSource);
}

## 修改 application.yml

修改 uaa-service 中的 application.yml 添加以下配置：
**spring**: **main**:
**allow-bean-definition-overriding**: **true**
允 许 bean 重 复 定 义 。 因 为 在 AuthorizationServer 中 增 加 了 对 ClientDetailsService 的定义，与框架自动配置的 ClientDetailsService 对象重复了。

## 测试
1、测试申请令牌使用密码模式申请令牌，客户端信息需要和数据库中的信息一致。
2、测试授权码模式生成的授权存储到数据库中。
注意如果要测试带令牌访问资源服务，记得对资源服务中的拦截配置进行修改，参考如下：
**public void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
_//	.antMatchers("/**").access("#oauth2.hasScope('all')")_
.antMatchers(**"/**"**).access(**"#oauth2.hasAnyScope('ROLE_A**
**DMIN','ROLE_USER','ROLE_API')"**)
.and().csrf().disable()
.sessionManagement().sessionCreationPolicy(SessionCreat ionPolicy.**_STATELESS_**);
}
因为在数据库中存储的客户端信息的 scope 字段已经发生了变化，不再是 “all”，因此需要对以上配置进行修改。
![](media/1677636897288-ded3e9ef-0a20-448c-989e-5b5a8ad00011.jpeg.jpg)

### Ouath2 流程总结
![](media/1677636898069-88410f23-7ca1-48ab-aaed-5a3e28775ff9.jpeg.jpg)

1、我们请求头中带着 Token 向资源服务器发送请求。
2、资源服务器收到请求，得到 Token 后通过 jwtAccessTokenConverter
转换器进行 Token 的转换得到 Token 中的认证授权信息。
3、然后资源服务器会校验认证信息中是否拥有资源服务器配置的授权范围 (Scope)，资源 ID(ResourceID)，如果都验证通过资源服务器还会校验权限列表是否包含当前访问的资源(controller)说需要的权限。
4、如果授权范围(Scope)，资源 ID(ResourceID)，方法授权都校验通过就执行相关的方法返回资源。

# 分布式系统授权案例
### 需求分析

回顾前面讲的技术方案，如下图：
![](media/1677636899849-d44e0139-6a58-4c2f-91bf-827a57c3f5d7.jpeg.jpg)
1、UAA 认证服务负责认证授权。
2、所有请求经过 网关到达微服务
3、网关负责鉴权客户端以及请求转发

4、网关将 token 解析后传给微服务，微服务进行授权。
### 网关

网关整合 OAuth2.0 有两种思路，一种是认证服务器生成 jwt 令牌, 所有请求统一在网关层验证，判断权限等操作； 另一种是由各资源服务处理，网关只做请求转发。
我们选用第一种。我们把 API 网关作为 OAuth2.0 的资源服务器角色，实现接入客户端权限拦截、令牌解析并转发当前登录用户信息( jsonToken)给微服务，这样下游微服务就不需要关心令牌格式解析以及 OAuth2.0 相关机制了。
API 网关在认证授权体系里主要负责两件事：

1. 作为 OAuth2.0 的资源服务器角色，实现接入方权限拦截。
2. 令牌解析并转发当前登录用户信息（明文 token）给微服务 。

微服务拿到明文token(明文token 中包含登录用户的身份和权限信息)后也需要做两件事：

1. 用户授权拦截（看当前用户是否有权访问该资源）
2. 将用户信息存储进当前线程上下文（有利于后续业务逻辑随时获取当前用户信息）
## 创建网关工程
在父工程下新建 gateway-server 网关模块，本案例中使用 zuul 网关。

##### 引入依赖

<**dependencies**>
<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-starter-netflix-zuul</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.cloud</**groupId**>
<**artifactId**>spring-cloud-starter-netflix-eureka- client</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.boot</**groupId**>
<**artifactId**>spring-boot-starter-web</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.projectlombok</**groupId**>
<**artifactId**>lombok</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>com.alibaba</**groupId**>
<**artifactId**>fastjson</**artifactId**>
</**dependency**>
<**dependency**>
<**groupId**>org.springframework.security.oauth.boot</**groupId**>
<**artifactId**>spring-security-oauth2- autoconfigure</**artifactId**>
</**dependency**>
</**dependencies**>



##### 添加配置

**server**: **port**: 8080
**spring**: **application**:
**name**: gateway-server
**zuul**:
**retryable**: **true ignored-services**: **"*" add-host-header**: **true sensitive-headers**: **"*" routes**:
**uaa-service**: **stripPrefix**: false **path**: /oauth/**
**order-service**: **stripPrefix**: false **path**: /order/**
**eureka**: **client**:
**service-url**:
**defaultZone**: [http://127.0.0.1:8761/eureka/](http://127.0.0.1:8761/eureka/)
**registry-fetch-interval-seconds**: 5 _# 获取服务列表的周期：5s_
**instance**:
**prefer-ip-address**: **true**

**logging**: **level**:
**root**: info

##### 添加启动类

@SpringBootApplication @EnableZuulProxy @EnableDiscoveryClient **public class **GatewayServer {
**public static void **main(String[] args) { SpringApplication._run_(GatewayServer.**class**, args);
}
}

##### Token 配置

前面也介绍了，资源服务器由于需要验证并解析令牌，往往可以通过在授权服务器暴露 check_token 的 Endpoint 来完成，而我们在授权服务器使用的是对称加密的 jwt，因此知道密钥即可，资源服务与授权服务本就是对称设计，那我们把授权服务的 TokenConfig 类拷贝过来放到 config 目录下就行。 @Configuration
**public class **TokenConfig {
**private static final **String **_SIGNING_KEY _**= **"hello-jwt"**;

_/**_
_* 配置令牌的存储方式_
_*/_
@Bean
**public **TokenStore tokenStore() {
**return new **JwtTokenStore(tokenConverter());
}

@Bean
**public **JwtAccessTokenConverter tokenConverter() { JwtAccessTokenConverter converter = **new**
JwtAccessTokenConverter();
_//使用对称加密,资源服务器使用该秘钥来验证_
converter.setSigningKey(**_SIGNING_KEY_**);
**return **converter;
}
}

##### 配置资源服务

在config 目录下新建ResouceServerConfig 类，用于定义资源服务配置，主要配置的内容就是定义一些匹配规则，描述某个接入客户端需要什么样的权限才能访问某个微服务，如：
@Configuration
**public class **ResourceServerConfig {
**public static final **String **_RESOURCE_ID _**= **"res1"**;

_//uaa 资源服务配置 _@Configuration @EnableResourceServer
**public class **UAAServerConfig **extends**
ResourceServerConfigurerAdapter { @Autowired
**private **TokenStore **tokenStore**;

@Override
**public void **configure(ResourceServerSecurityConfigurer resources) {

resources.tokenStore(**tokenStore**).resourceId(**_RESOURCE_ID_**)
.stateless(**true**);
}
@Override
**public void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
.antMatchers(**"/oauth/**"**).permitAll();
}
}
_//order 资源 _@Configuration @EnableResourceServer
**public class **OrderServerConfig **extends**
ResourceServerConfigurerAdapter { @Autowired
**private **TokenStore **tokenStore**;
@Override
**public void **configure(ResourceServerSecurityConfigurer resources) {

resources.tokenStore(**tokenStore**).resourceId(**_RESOURCE_ID_**)
.stateless(**true**);
}

@Override
**public void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
.antMatchers(**"/order/**"**)
.access(**"#oauth2.hasScope('ROLE_API')"**);
}
}
_//配置其它的资源服务.._
}
上面定义了两个微服务的资源，其中：
UAAServerConfig 指定了若请求匹配/oauth/**网关不进行拦截。 OrderServerConfig 指定了若请求匹配/order/**，也就是访问订单服务，接入客户端需要有 scope 中包含“ROLE_API”。

##### 安全配置

在 config 目录下新建安全配置类，参考如下：
@Configuration
**public class **WebSecurityConfig **extends**
WebSecurityConfigurerAdapter {

@Override
**protected void **configure(HttpSecurity http) **throws **Exception { http.authorizeRequests()
.antMatchers(**"/**"**).permitAll()
.and().csrf().disable();
}
}

### 转发token 给微服务

通过 Zuul 过滤器的方式实现，目的是让下游微服务能够很方便的获取到当
前的登录用户信息。
## 实现 Zuul 前置过滤器
完成当前登录用户信息提取，并放入转发微服务的 request 中。
@Component
**public class **AuthFilter **extends **ZuulFilter { @Override
**public boolean **shouldFilter() {
**return true**;
}

@Override
**public **String filterType() {
**return "pre"**;
}

@Override
**public int **filterOrder() {
**return **0;
}

@Override
**public **Object run() **throws **ZuulException {
RequestContext ctx = RequestContext._getCurrentContext_();
_//从安全上下文中拿 到用户身份对象_
Authentication authentication = SecurityContextHolder._getContext_().getAuthentication();
**if **(!(authentication **instanceof **OAuth2Authentication)) {
**return null**;
}
OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication;
Authentication userAuthentication = oAuth2Authentication.getUserAuthentication();
_//取出用户身份信息_
String principal = userAuthentication.getName();

_//取出用户权限_
List<String> authorities = **new **ArrayList<>();
_//从 userAuthentication 取出权限，放在 authorities_
userAuthentication.getAuthorities().forEach(c -> authorities.add(((GrantedAuthority) c).getAuthority()));
OAuth2Request oAuth2Request = oAuth2Authentication.getOAuth2Request();
Map<String, String> requestParameters = oAuth2Request.getRequestParameters();
Map<String, Object> jsonToken = **new**
HashMap<>(requestParameters); jsonToken.put(**"principal"**, principal); jsonToken.put(**"authorities"**, authorities);

_//把身份信息和权限信息放在 json 中，加入 http 的 header 中,转发给微服_
_务_
ctx.addZuulRequestHeader(**"json-token"**,
EncryptUtil._encodeUTF8StringBase64_(JSON._toJSONString_(jsonToken)))
;
**return null**;
}
}

## 工具类 EncryptUtil

**public class **EncryptUtil {
**private static final **Logger **_logger _**= LoggerFactory._getLogger_(EncryptUtil.**class**);

**public static **String encodeBase64(**byte**[] bytes){
String encoded = Base64._getEncoder_().encodeToString(bytes);
**return **encoded;
}

**public static byte**[] decodeBase64(String str){
**byte**[] bytes = **null**;
bytes = Base64._getDecoder_().decode(str);
**return **bytes;
}

**public static **String encodeUTF8StringBase64(String str){ String encoded = **null**;
**try **{
encoded = Base64._getEncoder_().encodeToString(str.getBytes(**"utf-8"**));
} **catch **(UnsupportedEncodingException e) {
**_logger_**.warn(**"不支持的编码格式"**,e);
}
**return **encoded;

}

**public static **String decodeUTF8StringBase64(String str){ String decoded = **null**;
**byte**[] bytes = Base64._getDecoder_().decode(str);
**try **{
decoded = **new **String(bytes,**"utf-8"**);
}**catch**(UnsupportedEncodingException e){
**_logger_**.warn(**"不支持的编码格式"**,e);
}
**return **decoded;
}

**public static **String encodeURL(String url) { String encoded = **null**;
**try **{
encoded = URLEncoder._encode_(url, **"utf-8"**);
} **catch **(UnsupportedEncodingException e) {
**_logger_**.warn(**"URLEncode 失败"**, e);
}
**return **encoded;
}



**public static **String decodeURL(String url) { String decoded = **null**;
**try **{
decoded = URLDecoder._decode_(url, **"utf-8"**);
} **catch **(UnsupportedEncodingException e) {
**_logger_**.warn(**"URLDecode 失败"**, e);
}
**return **decoded;
}

**public static void **main(String [] args){ String str = **"abcd{'a':'b'}"**;
String encoded = EncryptUtil._encodeUTF8StringBase64_(str); String decoded =
EncryptUtil._decodeUTF8StringBase64_(encoded); System.**_out_**.println(str); System.**_out_**.println(encoded); System.**_out_**.println(decoded);

String url = **"== wo"**;
String urlEncoded = EncryptUtil._encodeURL_(url);
String urlDecoded = EncryptUtil._decodeURL_(urlEncoded);

System.**_out_**.println(url); System.**_out_**.println(urlEncoded); System.**_out_**.println(urlDecoded);
}
}



## 跨域配置
在 config 目录下新建 ZuulConfig 配置类，添加以下配置：
@Configuration
**public class **ZuulConfig { @Bean
**public **FilterRegistrationBean corsFilter() {
**final **UrlBasedCorsConfigurationSource source = **new**
UrlBasedCorsConfigurationSource();
**final **CorsConfiguration config = **new **CorsConfiguration(); config.setAllowCredentials(**true**); config.addAllowedOrigin(**"*"**); config.addAllowedHeader(**"*"**); config.addAllowedMethod(**"*"**);
config.setMaxAge(18000L); source.registerCorsConfiguration(**"/**"**, config); CorsFilter corsFilter = **new **CorsFilter(source); FilterRegistrationBean bean = **new**
FilterRegistrationBean(corsFilter); bean.setOrder(Ordered.**_HIGHEST_PRECEDENCE_**); **return **bean;
}
}

   1. 微服务用户鉴权拦截

## 定义 Token 解析Filter
在资源服务order-service 中定义filter 拦截token，并形成Spring Security
的 Authentication 对象。
@Component
**public class **TokenAuthenticationFilter **extends**
OncePerRequestFilter { @Override
**protected void **doFilterInternal(HttpServletRequest request,
HttpServletResponse response, FilterChain filterChain)
**throws **ServletException, IOException {
String token = request.getHeader(**"json-token"**);
**if **(token != **null**) {
_//解析 token_
String json = EncryptUtil._decodeUTF8StringBase64_(token);
JSONObject jsonObject = (JSONObject) JSONObject._parse_(json);
UserDTO userDTO = JSON._parseObject_(jsonObject.getString(**"principal"**), UserDTO.**class**);
JSONArray authoritiesArray = jsonObject.getJSONArray(**"authorities"**);
String[] authorities = authoritiesArray.toArray(**new **String[authoritiesArray.size()]);
_//新建并填充 authentication_
UsernamePasswordAuthenticationToken authentication =
**new**

UsernamePasswordAuthenticationToken( userDTO, **null**,
AuthorityUtils._createAuthorityList_(authorities)); authentication.setDetails(**new**
WebAuthenticationDetailsSource().buildDetails( request));
_//将 authentication 保存进安全上下文_

SecurityContextHolder._getContext_().setAuthentication(authenticati on);
}
filterChain.doFilter(request, response);
}
}
经过上边的过虑器，资源服务中就可以方便到的获取用户的身份信息：
@RestController @RequestMapping(**"/order"**) **public class **OrderController {
@RequestMapping(value = **"/r1"**) @PreAuthorize(**"hasAnyAuthority('p1')"**) **public **String resourceOne() {
**return **getUserName() + **"访问资源 1"**;
}

@RequestMapping(value = **"/r2"**) @PreAuthorize(**"hasAnyAuthority('p2')"**) **public **String resourceTwo() {
**return **getUserName() + **"访问资源 2"**;
}

**private **String getUserName() { Authentication authentication =
SecurityContextHolder._getContext_().getAuthentication();
**if **(!authentication.isAuthenticated()) {
**return null**;
}
Object principal = authentication.getPrincipal(); String username;
**if **(principal **instanceof **UserDetails) { String usernameStr = ((UserDetails)
principal).getUsername();
UserDTO userDto = JSON._parseObject_(usernameStr, UserDTO.**class**);
username = userDto.getUsername();
} **else **{
UserDTO userDto = JSON._parseObject_(principal.toString(), UserDTO.**class**);
username = userDto.getUsername();
}
**return **username;
}
}
### 集成测试

本案例测试过程描述：
![](media/1677636911665-b89ebe2f-777b-4d26-824c-739f97d2342d.jpeg.jpg)1、采用 OAuth2.0 的密码模式通过网关获取 token
2、使用该 token 通过网关访问订单服务的测试资源


![](media/1677636913866-2d332ca7-8cae-4476-bcc8-ba64407caf0c.jpeg.jpg)
